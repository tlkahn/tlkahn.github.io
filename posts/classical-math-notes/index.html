<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="How to render katex">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="Notes on classical ML math" />
<meta property="og:description" content="How to render katex" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/classical-math-notes/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-04-03T22:00:05+08:00" />
<meta property="article:modified_time" content="2024-04-03T22:00:05+08:00" />
<title>Notes on classical ML math | My New Hugo Site</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" >
<link rel="canonical" href="http://localhost:1313/posts/classical-math-notes/">
<link rel="stylesheet" href="/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css" integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz&#43;OQteg=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.d0342a685176bb928359d036d3a747435d86416bc5cc361b54879826c6bba762.js" integrity="sha256-0DQqaFF2u5KDWdA206dHQ12GQWvFzDYbVIeYJsa7p2I=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>My New Hugo Site</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  
















</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Notes on classical ML math</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#frequentist">Frequentist</a></li>
    <li><a href="#bayesian">Bayesian</a></li>
  </ul>

  <ul>
    <li><a href="#1-d-mle">1-d MLE</a></li>
    <li><a href="#multivariate-gaussian">Multivariate Gaussian</a></li>
  </ul>

  <ul>
    <li><a href="#least-squares-method">Least squares method</a></li>
    <li><a href="#mle-with-gaussian-noise">MLE with Gaussian noise</a></li>
    <li><a href="#gaussian-weight-prior-in-map-maximum-a-posteriori-estimation">Gaussian weight prior in MAP (Maximum A Posteriori) estimation.</a></li>
    <li><a href="#regularization">Regularization</a>
      <ul>
        <li><a href="#l1-lasso">L1 Lasso</a></li>
        <li><a href="#l2-ridge">L2 Ridge</a></li>
      </ul>
    </li>
    <li><a href="#summary">Summary</a></li>
  </ul>

  <ul>
    <li><a href="#hard">Hard</a>
      <ul>
        <li><a href="#perceptron">Perceptron</a></li>
        <li><a href="#lda">LDA</a></li>
      </ul>
    </li>
    <li><a href="#soft">Soft</a>
      <ul>
        <li><a href="#logistic-regression">Logistic regression</a></li>
        <li><a href="#gaussian-discrimination-analysis">Gaussian Discrimination Analysis</a></li>
        <li><a href="#naive-bayes">Naive Bayes</a></li>
      </ul>
    </li>
    <li><a href="#summary-1">Summary</a></li>
  </ul>

  <ul>
    <li><a href="#constrained-optimization">Constrained Optimization</a></li>
    <li><a href="#hard-margin-svm">Hard-margin SVM</a></li>
    <li><a href="#soft-margin-svm">Soft-margin SVM</a></li>
    <li><a href="#kernel-method">Kernel Method</a></li>
    <li><a href="#summary-2">Summary</a></li>
  </ul>

  <ul>
    <li><a href="#1-_d_-gaussian-distribution">1-<em>d</em> Gaussian distribution</a></li>
    <li><a href="#sufficient-statistics-and-log-partition-functions">Sufficient statistics and log partition functions</a></li>
    <li><a href="#sufficient-statistics-and-mle">Sufficient statistics and MLE</a></li>
    <li><a href="#maximum-entrophy">Maximum entrophy</a></li>
  </ul>

  <ul>
    <li><a href="#generalized-em">Generalized EM</a></li>
    <li><a href="#generalization-of-em">Generalization of EM</a></li>
  </ul>

  <ul>
    <li><a href="#mle">MLE</a></li>
    <li><a href="#solve-gmm-using-em">Solve GMM using EM</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
<article class="markdown book-post">
  <h1>
    <a href="/posts/classical-math-notes/">Notes on classical ML math</a>
  </h1>
  
  <h5>April 3, 2024</h5>



  

  



<h1 id="introduction">
  Introduction
  <a class="anchor" href="#introduction">#</a>
</h1>
<p>There are two major schools of thought on the interpretation of probability: one is the frequentist school and the other is the Bayesian school.</p>
<p>Later, we will use the following notation for the observed set: 
<link rel="stylesheet" href="/katex/katex.min.css" />
<script defer src="/katex/katex.min.js"></script>
<script defer src="/katex/auto-render.min.js" onload="renderMathInElement(document.body);"></script><span>
  \(X_{N\times p}=(x_{1},x_{2},\cdots,x_{N})^{T},x_{i}=(x_{i1},x_{i2},\cdots,x_{ip})^{T}\)
</span>
</p>
<p>This notation indicates there are <span>
  \(N\)
</span>
 samples, and each sample is a <span>
  \(p\)
</span>
-dimensional vector. Each observation is generated by <span>
  \(p(x|\theta)\)
</span>
.</p>
<h2 id="frequentist">
  Frequentist
  <a class="anchor" href="#frequentist">#</a>
</h2>
<p>Frequentists hold that in <span>
  \(p(x|\theta)\)
</span>
, <span>
  \(\theta\)
</span>
 as a parameter is a constant. For <span>
  \(N\)
</span>
 observations, the probability of the observed set is <span>
  \(p(X|\theta)\mathop{=}\limits _{iid}\prod\limits _{i=1}^{N}p(x_{i}|\theta))\)
</span>
. To find the value of <span>
  \(\theta\)
</span>
, we use the maximum log-likelihood (MLE) method:</p>
<span>
  \(\theta_{MLE}=\mathop{argmax}\limits _{\theta}\log p(X|\theta)\mathop{=}\limits _{iid}\mathop{argmax}\limits _{\theta}\sum\limits _{i=1}^{N}\log p(x_{i}|\theta)\)
</span>

<h2 id="bayesian">
  Bayesian
  <a class="anchor" href="#bayesian">#</a>
</h2>
<p>Bayesians believe that <span>
  \(\theta\)
</span>
 in <span>
  \(p(x|\theta)\)
</span>
 is not a constant. This <span>
  \(\theta\)
</span>
 follows a preset prior distribution <span>
  \(\theta\sim p(\theta)\)
</span>
. So, according to Bayes' theorem, the parameter's posterior distribution based on the observed set can be written as:</p>
<span>
  \(p(\theta|X)=\frac{p(X|\theta)\cdot p(\theta)}{p(X)}=\frac{p(X|\theta)\cdot p(\theta)}{\int\limits _{\theta}p(X|\theta)\cdot p(\theta)d\theta} \propto p(X|\theta)\cdot p(\theta)\)
</span>

<p>To find the value of <span>
  \(\theta\)
</span>
, we need to maximize this parameter's posterior distribution using the MAP (Maximum A Posteriori) method:</p>
<span>
  \(\theta_{MAP}=\mathop{argmax}\limits _{\theta}p(\theta|X)=\mathop{argmax}\limits _{\theta}p(X|\theta)\cdot p(\theta)\)
</span>

<p>The second equality is due to the denominator being unrelated to <span>
  \(\theta\)
</span>
.</p>
<p><span>
  \(p(X|\theta)\)
</span>
 is called the likelihood and represents our model distribution. After obtaining the posterior distribution of the parameters, we can use it for Bayesian prediction:</p>
<span>
  \(p(x_{new}|X)=\int\limits _{\theta}p(x_{new}|\theta)\cdot p(\theta|X)d\theta\)
</span>

<p>In this integral, the multiplicand is the model (likelihood), and the multiplier is the posterior distribution.</p>
<p>Here's the derivation:</p>
<ol>
<li>
<p>Start with the joint probability of observing <span>
  \(x_{new}\)
</span>
 and <span>
  \(\theta\)
</span>
 given <span>
  \(X\)
</span>
: <span>
  \(p(x_{new}, \theta|X) = p(x_{new}|\theta, X) \cdot p(\theta|X)\)
</span>
</p>
</li>
<li>
<p>To find the marginal probability of observing <span>
  \(x_{new}\)
</span>
 given <span>
  \(X\)
</span>
, integrate the joint probability over all possible values of <span>
  \(\theta\)
</span>
: <span>
  \(p(x_{new}|X) = \int\limits_{\theta} p(x_{new}, \theta|X) d\theta\)
</span>
</p>
</li>
<li>
<p>Substitute the joint probability from step 1 into the integral: <span>
  \(p(x_{new}|X) = \int\limits_{\theta} [p(x_{new}|\theta, X) \cdot p(\theta|X)] d\theta\)
</span>
</p>
</li>
<li>
<p>Since <span>
  \(x_{new}\)
</span>
 is conditionally independent of <span>
  \(X\)
</span>
 given <span>
  \(\theta\)
</span>
, we can simplify <span>
  \(p(x_{new}|\theta, X)\)
</span>
 as <span>
  \(p(x_{new}|\theta)\)
</span>
: <span>
  \(p(x_{new}|X) = \int\limits_{\theta} [p(x_{new}|\theta) \cdot p(\theta|X)] d\theta\)
</span>
</p>
</li>
</ol>
<p>The final result is the given formula:</p>
<span>
  \(p(x_{new}|X) = \int\limits_{\theta} p(x_{new}|\theta) \cdot p(\theta|X) d\theta\)
</span>

<h1 id="gaussian-distribution">
  Gaussian Distribution
  <a class="anchor" href="#gaussian-distribution">#</a>
</h1>
<h2 id="1-d-mle">
  1-d MLE
  <a class="anchor" href="#1-d-mle">#</a>
</h2>
<p><span>
  \(\theta\)
</span>
 of Gaussian in 1-d MLE</p>
<p><span class="optional">
  \[\begin{aligned}
&amp;\theta=(\mu,\Sigma)=(\mu,\sigma^{2}), \\
&amp;\theta_{MLE}=\mathop{argmax}\limits_{\theta}\log p(X|\theta)\mathop{=}\limits_{iid}\mathop{argmax}\limits_{\theta}\sum\limits _{i=1}^{N}\log p(x_{i}|\theta)
\end{aligned}\]
</span>

Probability density function (PDF) of the multivariate Gaussian distribution in <span>
  \(p\)
</span>
-d with mean vector <span>
  \(\mu\)
</span>
 and covariance matrix <span>
  \(\Sigma\)
</span>
 is written as: <span>
  \(p(x|\mu,\Sigma)=\frac{1}{(2\pi)^{p/2}|\Sigma|^{1/2}}e^{-\frac{1}{2}(x-\mu)^{T}\Sigma^{-1}(x-\mu)}\)
</span>
 Plugging into MLE, we consider the one-dimensional case: <span>
  \(\log p(X|\theta)=\sum\limits _{i=1}^{N}\log p(x_{i}|\theta)=\sum\limits _{i=1}^{N}\log\frac{1}{\sqrt{2\pi}\sigma}\exp(-(x_{i}-\mu)^{2}/2\sigma^{2})\)
</span>
 To find <span>
  \(\mu_{MLE}\)
</span>
:</p>
<p><span>
  \(\mu_{MLE}=\mathop{argmax}\limits _{\mu}\log p(X|\theta)=\mathop{argmax}\limits _{\mu}\sum\limits _{i=1}^{N}(x_{i}-\mu)^{2}\)
</span>
 <span>
  \(\frac{\partial}{\partial\mu}\sum\limits _{i=1}^{N}(x_{i}-\mu)^{2}=0\longrightarrow\mu_{MLE}=\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}\)
</span>
 For <span>
  \(\sigma\)
</span>
, we have:</p>
<p><span class="optional">
  \[\begin{aligned}
\sigma_{MLE}=\mathop{argmax}\limits _{\sigma}\log p(X|\theta)&amp;=\mathop{argmax}\limits _{\sigma}\sum\limits _{i=1}^{N}[-\log\sigma-\frac{1}{2\sigma^{2}}(x_{i}-\mu)^{2}]\\
&amp;=\mathop{argmin}\limits _{\sigma}\sum\limits _{i=1}^{N}[\log\sigma&#43;\frac{1}{2\sigma^{2}}(x_{i}-\mu)^{2}]
\end{aligned}\]
</span>

<span>
  \(\therefore\)
</span>
 <span>
  \(\frac{\partial}{\partial\sigma}\sum\limits _{i=1}^{N}[\log\sigma&#43;\frac{1}{2\sigma^{2}}(x_{i}-\mu)^{2}]=0\)
</span>
</p>
<p>Given the log-likelihood function to optimize: <span>
  \(\sum\limits_{i=1}^{N}[\log\sigma &#43; \frac{1}{2\sigma^2}(x_i - \mu)^2]\)
</span>
</p>
<ol>
<li>
<p>Differentiate the log-likelihood function with respect to <span>
  \(\sigma\)
</span>
: <span>
  \(\frac{\partial}{\partial\sigma}\sum\limits_{i=1}^{N}[\log\sigma &#43; \frac{1}{2\sigma^2}(x_i - \mu)^2]\)
</span>
</p>
</li>
<li>
<p>Apply the sum rule and chain rule for differentiation: <span>
  \(N \cdot \frac{1}{\sigma} - \sum\limits_{i=1}^{N}\frac{(x_i - \mu)^2}{\sigma^3} = 0\)
</span>
</p>
</li>
<li>
<p>Solve for <span>
  \(\sigma^2\)
</span>
: <span>
  \(\frac{1}{\sigma} = \frac{1}{N \sigma^3}\sum\limits_{i=1}^{N}(x_i - \mu)^2 \longrightarrow \sigma^2 = \frac{1}{N}\sum\limits_{i=1}^{N}(x_i - \mu)^2\)
</span>
</p>
</li>
</ol>
<p>The result is the MLE of the variance: <span>
  \(\sigma_{MLE}^2 = \frac{1}{N}\sum\limits_{i=1}^{N}(x_i - \mu)^2\)
</span>
</p>
<p>Since we have <span>
  \(\sigma^2_{MLE}\)
</span>
, for a unbiased estimate of <span>
  \(\mathbb{E}_D [\sigma^2_{MLE}]\)
</span>
:</p>
<p><span class="optional">
  \[\begin{aligned}
\mathbb{E}_{\mathcal{D}}[\sigma_{MLE}^{2}]&amp;=\mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}(x_{i}-\mu_{MLE})^{2}]=\mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}(x_{i}^{2}-2x_{i}\mu_{MLE}&#43;\mu_{MLE}^{2})
\\&amp;=\mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}^{2}-\mu_{MLE}^{2}]=\mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}^{2}-\mu^{2}&#43;\mu^{2}-\mu_{MLE}^{2}]\\
&amp;= \mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}^{2}-\mu^{2}]-\mathbb{E}_{\mathcal{D}}[\mu_{MLE}^{2}-\mu^{2}]=\sigma^{2}-(\mathbb{E}_{\mathcal{D}}[\mu_{MLE}^{2}]-\mu^{2})\\&amp;=\sigma^{2}-(\mathbb{E}_{\mathcal{D}}[\mu_{MLE}^{2}]-\mathbb{E}_{\mathcal{D}}^{2}[\mu_{MLE}])=\sigma^{2}-Var[\mu_{MLE}]\\&amp;=\sigma^{2}-Var[\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}]=\sigma^{2}-\frac{1}{N^{2}}\sum\limits _{i=1}^{N}Var[x_{i}]=\frac{N-1}{N}\sigma^{2}
\end{aligned}\]
</span>

<span>
  \(\therefore\)
</span>
 for <span>
  \(\hat{\sigma}^{2}\)
</span>
 a.k.a <span>
  \(\mathbb{E}_{\mathcal{D}}[\sigma_{MLE}^{2}]\)
</span>
:</p>
<span>
  \(\hat{\sigma}^{2}=\frac{1}{N-1}\sum\limits _{i=1}^{N}(x_{i}-\mu)^{2}\)
</span>

<h2 id="multivariate-gaussian">
  Multivariate Gaussian
  <a class="anchor" href="#multivariate-gaussian">#</a>
</h2>
<span>
  \(\because\)
</span>

<span>
  \(p(x|\mu,\Sigma)=\frac{1}{(2\pi)^{p/2}|\Sigma|^{1/2}}e^{-\frac{1}{2}(x-\mu)^{T}\Sigma^{-1}(x-\mu)}\)
</span>

<p>Here, <span>
  \(x,\mu\in\mathbb{R}^{p},\Sigma\in\mathbb{R}^{p\times p}\)
</span>
, where <span>
  \(\Sigma\)
</span>
 is the covariance matrix, generally also a semi-positive definite matrix.</p>
<p>First, we deal with the number in the exponent, which can be denoted as the Mahalanobis distance between <span>
  \(x\)
</span>
 and <span>
  \(\mu\)
</span>
.</p>
<p>The Mahalanobis distance is a method for measuring the distance between data points, taking into account the covariance structure of the data. For two points <span>
  \(x\)
</span>
 and <span>
  \(y\)
</span>
, their Mahalanobis distance is defined as:</p>
<span>
  \(D_{M}(x, y) = \sqrt{(x - y)^T \Sigma^{-1} (x - y)}\)
</span>

<p>Here, <span>
  \(\Sigma\)
</span>
 is the covariance matrix of the data. The difference between Mahalanobis distance and Euclidean distance lies in the fact that the former takes into account the shape of the data distribution, especially the correlation between the data. When the covariance matrix of the data is an identity matrix, the Mahalanobis distance is equal to the Euclidean distance.</p>
<p>The covariance matrix of the data is used to represent the degree of joint variation between different dimensions in the data. For a dataset with <span>
  \(n\)
</span>
 samples and <span>
  \(p\)
</span>
 features, the covariance matrix <span>
  \(\Sigma\)
</span>
 is a <span>
  \(p \times p\)
</span>
 matrix, defined as:</p>
<span>
  \(\Sigma = \frac{1}{n-1} \sum\limits_{i=1}^n (x_i - \bar{x})(x_i - \bar{x})^T\)
</span>

<p>Here, <span>
  \(x_i\)
</span>
 is the <span>
  \(i\)
</span>
-th sample point, <span>
  \(\bar{x}\)
</span>
 is the sample mean, and <span>
  \(n\)
</span>
 is the number of samples.</p>
<p>This equation defines a matrix because each summand <span>
  \((x_i - \bar{x})(x_i - \bar{x})^T\)
</span>
 itself is a matrix. Let's explain this in more detail:</p>
<p>Suppose <span>
  \(x_i\)
</span>
 and <span>
  \(\bar{x}\)
</span>
 are <span>
  \(p\)
</span>
-dimensional column vectors, then <span>
  \((x_i - \bar{x})\)
</span>
 is also a <span>
  \(p\)
</span>
-dimensional column vector. When calculating the outer product <span>
  \((x_i - \bar{x})(x_i - \bar{x})^T\)
</span>
, we obtain a <span>
  \(p \times p\)
</span>
 matrix, where each element is the product of the corresponding elements in <span>
  \((x_i - \bar{x})\)
</span>
.</p>
<p>Summing these <span>
  \(p \times p\)
</span>
 matrices over the sample size <span>
  \(n\)
</span>
, we obtain a cumulative <span>
  \(p \times p\)
</span>
 matrix. Finally, the entire sum is divided by <span>
  \((n-1)\)
</span>
 to obtain the unbiased covariance matrix <span>
  \(\Sigma\)
</span>
.</p>
<p>The denominator is <code>n-1</code>{.verbatim} rather than <code>n</code>{.verbatim} because of <a href="https://en.wikipedia.org/wiki/Bessel%27s_correction">Bessel's correction</a>, which is used to provide an unbiased estimate of the population variance when working with sample data.</p>
<p>For a symmetric covariance matrix, eigendecomposition can be performed.</p>
<span>
  \(\Sigma=U\Lambda U^{T}=(u_{1},u_{2},\cdots,u_{p})diag(\lambda_{i})(u_{1},u_{2},\cdots,u_{p})^{T}=\sum\limits _{i=1}^{p}u_{i}\lambda_{i}u_{i}^{T}\)
</span>

<span>
  \(\Sigma^{-1}=\sum\limits _{i=1}^{p}u_{i}\frac{1}{\lambda_{i}}u_{i}^{T}\)
</span>

<p>In this context, <span>
  \(u_i\)
</span>
 is the eigenvector of the covariance matrix <span>
  \(\Sigma\)
</span>
. Eigendecomposition decomposes the matrix into a product of eigenvectors <span>
  \(u_i\)
</span>
 and eigenvalues <span>
  \(\lambda_i\)
</span>
. <span>
  \(U\)
</span>
 is a matrix composed of <span>
  \(u_i\)
</span>
 as column vectors corresponding to the eigenvectors. <span>
  \(\Lambda\)
</span>
 is a diagonal matrix with elements on the diagonal being the corresponding eigenvalues <span>
  \(\lambda_i\)
</span>
.</p>
<p><span class="optional">
  \[\begin{aligned}
\Delta&amp;=(x-\mu)^{T}\Sigma^{-1}(x-\mu) \\ &amp;=\sum\limits _{i=1}^{p}(x-\mu)^{T}u_{i}\frac{1}{\lambda_{i}}u_{i}^{T}(x-\mu) \\ &amp;=\sum\limits _{i=1}^{p}\frac{y_{i}^{2}}{\lambda_{i}} \tag{eq:1}
\end{aligned}\]
</span>

<span>
  \( y_i = (x-\mu)^T u_i = u_i^T (x-\mu) \)
</span>
</p>
<p>We notice that scalar <span>
  \(y_i\)
</span>
 is the projection of <span>
  \(x-\mu\)
</span>
 onto the eigenvector <span>
  \(u_i\)
</span>
 (or the inverse).</p>
<p>Specifically, <span>
  \(u_i^T(x - \mu)\)
</span>
 calculates the dot product between <span>
  \((x - \mu)\)
</span>
 and <span>
  \(u_i\)
</span>
, which gives the component of <span>
  \((x - \mu)\)
</span>
 in the direction of <span>
  \(u_i\)
</span>
. This is why we say <span>
  \(y_i\)
</span>
 is the projection of <span>
  \((x - \mu)\)
</span>
 onto the eigenvector <span>
  \(u_i\)
</span>
.</p>
<p>In Euclidean space, the dot product (also known as the inner product) is a fundamental operation between two vectors, used to calculate their components (or projections) in the same direction. The formula for calculating Euclidean dot product is:</p>
<span>
  \(u_i^T (x - \mu) = ||u_i|| ||x - \mu|| \cos{\theta}\)
</span>

<p>Where <span>
  \(||u_i||\)
</span>
 and <span>
  \(||x - \mu||\)
</span>
 represent the lengths of the vectors <span>
  \(u_i\)
</span>
 and <span>
  \((x - \mu)\)
</span>
, respectively, and <span>
  \(\theta\)
</span>
 represents the angle between them. Since the eigenvector <span>
  \(u_i\)
</span>
 is typically normalized to have unit length, i.e., <span>
  \(||u_i|| = 1\)
</span>
, the dot product simplifies to:</p>
<span>
  \(y_i = u_i^T (x - \mu) = ||x - \mu|| \cos{\theta}\)
</span>

<p><span>
  \(\ref{eq:1}\)
</span>
 represents a generalized concentric ellipses for different values of <span>
  \(\Delta\)
</span>
.</p>
<p>Each term <span>
  \(\frac{y_{i}^{2}}{\lambda_{i}}\)
</span>
 represents the contribution of the projection of the vector <span>
  \((x - \mu)\)
</span>
 onto the eigenvector <span>
  \(u_i\)
</span>
 to the overall shape of the ellipse. The eigenvalues <span>
  \(\lambda_i\)
</span>
 determine the scaling of the ellipse along each eigenvector direction.</p>
<p>Now let's look at two issues in the practical application of multidimensional Gaussian models:</p>
<ol>
<li>
<p>The number of degrees of freedom for parameters <span>
  \(\Sigma,\mu\)
</span>
 is <span>
  \(O(p^{2})\)
</span>
. For high-dimensional data, this leads to too many degrees of freedom.</p>
<p>Solution: The high degrees of freedom come from <span>
  \(\Sigma\)
</span>
 having <span>
  \(\frac{p(p&#43;1)}{2}\)
</span>
 free parameters. We can assume that it is a diagonal matrix or even assume that the elements on the diagonal are the same under the isotropic assumption. The former dimension reduction algorithm is Factor Analysis (FA), and the latter is probabilistic PCA (p-PCA).</p>
</li>
<li>
<p>The second problem is that a single Gaussian distribution is unimodal, and it cannot achieve good results for data distributions with multiple peaks. Solution: Gaussian Mixture Model (GMM).</p>
</li>
</ol>
<p>Next, we will introduce commonly used theorems for multidimensional Gaussian distributions.</p>
<p>Let <span>
  \(x=(x_1, x_2,\cdots,x_p)^T=(x_{a,m\times 1}, x_{b,n\times1})^T,\mu=(\mu_{a,m\times1}, \mu_{b,n\times1}),\Sigma=\begin{pmatrix}\Sigma_{aa}&amp;\Sigma_{ab}\\\Sigma_{ba}&amp;\Sigma_{bb}\end{pmatrix}\)
</span>
</p>
<p>Given: <span>
  \(x\sim\mathcal{N}(\mu,\Sigma)\)
</span>
</p>
<p>Given <span>
  \(x \sim \mathcal{N}(\mu, \Sigma)\)
</span>
, and <span>
  \(y \sim Ax &#43; b\)
</span>
, then <span>
  \(y \sim \mathcal{N}(A\mu &#43; b, A\Sigma A^T)\)
</span>
.</p>
<p><span>
  \(\mathbb{E}[y]=\mathbb{E}[Ax&#43;b]=A\mathbb{E}[x]&#43;b=A\mu&#43;b\)
</span>
 \
<span>
  \(Var[y]=Var[Ax&#43;b]=Var[Ax]=A\cdot Var[x]\cdot A^T\)
</span>
</p>
<p>Now, using this theorem, we can obtain four quantities <span>
  \(p(x_a), p(x_b), p(x_a|x_b), p(x_b|x_a)\)
</span>
</p>
<ol>
<li>
<p><span>
  \(x_a = \begin{pmatrix}\mathbb{I}_{m\times m} &amp; \mathbb{O}_{m\times n}\end{pmatrix}\begin{pmatrix}x_a \\ x_b\end{pmatrix}\)
</span>
.</p>
<p>Substituting into the theorem, we get:</p>
<p><span class="optional">
  \[    \begin{aligned}
      \mathbb{E}[x_a] = \begin{pmatrix}\mathbb{I} &amp; \mathbb{O}\end{pmatrix}\begin{pmatrix}\mu_a \\
      \mu_b\end{pmatrix} = \mu_a \\
      Var[x_a] = \begin{pmatrix}\mathbb{I} &amp; \mathbb{O}\end{pmatrix}\begin{pmatrix}\Sigma_{aa} &amp; \Sigma_{ab} \\ \Sigma_{ba} &amp; \Sigma_{bb}\end{pmatrix}\begin{pmatrix}\mathbb{I} \\
      \mathbb{O}\end{pmatrix} = \Sigma_{aa}
      \end{aligned}
    \]
</span>

<span>
  \(\therefore\)
</span>
</p>
<span>
  \(x_a \sim \mathcal{N}(\mu_a, \Sigma_{aa})\)
</span>

</li>
<li>
<p>Similarly, <span>
  \(x_b \sim \mathcal{N}(\mu_b, \Sigma_{bb})\)
</span>
.</p>
</li>
<li>
<p>For the two conditional probabilities, we introduce three quantities:</p>
<span>
  \(      x_{b\cdot a} = x_b - \Sigma_{ba}\Sigma_{aa}^{-1}x_a\\
      \mu_{b\cdot a} = \mu_b - \Sigma_{ba}\Sigma_{aa}^{-1}\mu_a\\
      \Sigma_{bb\cdot a} = \Sigma_{bb} - \Sigma_{ba}\Sigma_{aa}^{-1}\Sigma_{ab}
      \)
</span>

<p>In particular, the last equation is called the Schur Complementary of <span>
  \(\Sigma_{bb}\)
</span>
. We can see that: <span>
  \(      x_{b\cdot a} = \begin{pmatrix}-\Sigma_{ba}\Sigma_{aa}^{-1} &amp; \mathbb{I}_{n\times n}\end{pmatrix}\begin{pmatrix}x_a \\ x_b\end{pmatrix}
      \)
</span>
</p>
<p>So</p>
<p><span class="optional">
  \[    \begin{aligned}
       \mathbb{E}[x_{b\cdot a}] &amp;= \begin{pmatrix}-\Sigma_{ba}\Sigma_{aa}^{-1} &amp; \mathbb{I}_{n\times n}\end{pmatrix}\begin{pmatrix}\mu_a \\ \mu_b\end{pmatrix} = \mu_{b\cdot a}\\
       Var[x_{b\cdot a}] &amp;= \begin{pmatrix}-\Sigma_{ba}\Sigma_{aa}^{-1} &amp; \mathbb{I}_{n\times n}\end{pmatrix}\begin{pmatrix}\Sigma_{aa} &amp; \Sigma_{ab} \\ \Sigma_{ba} &amp; \Sigma_{bb}\end{pmatrix}\begin{pmatrix}-\Sigma_{aa}^{-1}\Sigma_{ba}^T \\ \mathbb{I}_{n\times n}\end{pmatrix} = \Sigma_{bb\cdot a}
      \end{aligned}
    \]
</span>

Using these three quantities, we can get <span>
  \(x_b = x_{b\cdot a} &#43; \Sigma_{ba}\Sigma_{aa}^{-1}x_a\)
</span>
.</p>
<p>Therefore: <span>
  \(      \mathbb{E}[x_b|x_a] = \mu_{b\cdot a} &#43; \Sigma_{ba}\Sigma_{aa}^{-1}x_a
      \)
</span>
 <span>
  \(      Var[x_b|x_a] = \Sigma_{bb\cdot a}
      \)
</span>
</p>
</li>
<li>
<p>Similarly: <span>
  \(      x_{a\cdot b} = x_a - \Sigma_{ab}\Sigma_{bb}^{-1}x_b\\
      \mu_{a\cdot b} = \mu_a - \Sigma_{ab}\Sigma_{bb}^{-1}\mu_b\\
      \Sigma_{aa\cdot b} = \Sigma_{aa} - \Sigma_{ab}\Sigma_{bb}^{-1}\Sigma_{ba}
      \)
</span>
</p>
<p><span>
  \(\therefore\)
</span>
 <span>
  \(      \mathbb{E}[x_a|x_b] = \mu_{a\cdot b} &#43; \Sigma_{ab}\Sigma_{bb}^{-1}x_b
      \)
</span>
 <span>
  \(      Var[x_a|x_b] = \Sigma_{aa\cdot b}
      \)
</span>
</p>
</li>
</ol>
<p>\begin{example}
Given:
<span>
  \(p(x) = \mathcal{N}(\mu, \Lambda^{-1}), p(y|x) = \mathcal{N}(Ax &#43; b, L^{-1})\)
</span>
, find: <span>
  \(p(y), p(x|y)\)
</span>
.
Solution:
Let:
<span>
  \(y = Ax &#43; b &#43; \epsilon, \epsilon \sim \mathcal{N}(0, L^{-1})\)
</span>
,
<span>
  \(\therefore\)
</span>

<span>
  \(\begin{aligned}
\mathbb{E}[y] = \mathbb{E}[Ax &#43; b &#43; \epsilon] = A\mu &#43; b
Var[y] = A\Lambda^{-1}A^T &#43; L^{-1}
\end{aligned}\)
</span>

<span>
  \(\therefore\)
</span>

<span>
  \(  p(y) = \mathcal{N}(A\mu &#43; b, L^{-1} &#43; A\Lambda^{-1}A^T)\)
</span>

Introduce:
<span>
  \(z = \begin{pmatrix}x \\ y\end{pmatrix}\)
</span>
, we can obtain <span>
  \(Cov[x, y] = \mathbb{E}[(x - \mathbb{E}[x])(y - \mathbb{E}[y])^T]\)
</span>
.
For this covariance, we can directly compute: <span>
  \(  \begin{aligned}
  Cov(x, y) &amp;= \mathbb{E}[(x - \mu)(Ax - A\mu &#43; \epsilon)^T] = \mathbb{E}[(x - \mu)(x - \mu)^TA^T] = Var[x]A^T = \Lambda^{-1}A^T
  \end{aligned}\)
</span>

Note the symmetry of the covariance matrix:
<span>
  \(p(z) = \mathcal{N}\begin{pmatrix}\mu \\ A\mu &#43; b\end{pmatrix}, \begin{pmatrix}\Lambda^{-1} &amp; \Lambda^{-1}A^T \\ A\Lambda^{-1} &amp; L^{-1} &#43; A\Lambda^{-1}A^T\end{pmatrix}\)
</span>
.
<span>
  \(\therefore\)
</span>

<span>
  \(  \mathbb{E}[x|y] = \mu &#43; \Lambda^{-1}A^T(L^{-1} &#43; A\Lambda^{-1}A^T)^{-1}(y - A\mu - b)
  \)
</span>

<span>
  \(  Var[x|y] = \Lambda^{-1} - \Lambda^{-1}A^T(L^{-1} &#43; A\Lambda^{-1}A^T)^{-1}A\Lambda^{-1}\)
</span>

\end{example}</p>
<h1 id="linear-regression">
  Linear Regression
  <a class="anchor" href="#linear-regression">#</a>
</h1>
<p>\epigraph{If AI thinks in matrix, so should human.}{anonymous}</p>
<p>Suppose we have dataset <span>
  \(\mathcal{D}\)
</span>
: <span>
  \(\mathcal{D}=\{(x_1, y_1),(x_2, y_2),\cdots,(x_N, y_N)\}\)
</span>
 We annotate <span>
  \(X\)
</span>
 as samples and <span>
  \(Y\)
</span>
 as target: <span>
  \(X=(x_1,x_2,\cdots,x_N)^T,Y=(y_1,y_2,\cdots,y_N)^T\)
</span>
 We are looking at a linear function: <span>
  \(f(w)=w^Tx\)
</span>
</p>
<h2 id="least-squares-method">
  Least squares method
  <a class="anchor" href="#least-squares-method">#</a>
</h2>
<p>For this problem, we use the squared error defined by the Euclidean norm to define the loss function: <span>
  \(L(w) = \sum\limits_{i=1}^N ||w^Tx_i - y_i||^2_2\)
</span>
</p>
<p>Expand it, we get:</p>
<p><span class="optional">
  \[\begin{aligned}
L(w)&amp;=(w^Tx_1-y_1,\cdots,w^Tx_N-y_N)\cdot (w^Tx_1-y_1,\cdots,w^Tx_N-y_N)^T\\
&amp;=(w^TX^T-Y^T)\cdot (Xw-Y)=w^TX^TXw-Y^TXw-w^TX^TY&#43;Y^TY\\
&amp;=w^TX^TXw-2w^TX^TY&#43;Y^TY
\end{aligned}\]
</span>

Now minimize <span>
  \(\hat{w}\)
</span>
</p>
<p><span class="optional">
  \[\begin{aligned}
\hat{w}=\mathop{argmin}\limits_wL(w)&amp;\longrightarrow\frac{\partial}{\partial w}L(w)=0\\
&amp;\longrightarrow2X^TX\hat{w}-2X^TY=0\\
&amp;\longrightarrow \hat{w}=(X^TX)^{-1}X^TY=X^&#43;Y
\end{aligned}\]
</span>

<span>
  \((X^TX)^{-1}X^T\)
</span>
 is also called the pseudo-inverse. We annote: <span>
  \(X^&#43; = (X^TX)^-1X^T\)
</span>
</p>
<p>For row full rank or column full rank <span>
  \(X\)
</span>
, the solution can be obtained directly, but for non-full rank sample sets, the singular value decomposition (SVD) method is needed. Apply Singular Value Decomposition (SVD) to <span>
  \(X\)
</span>
, we get <span>
  \(X=U\Sigma V^T\)
</span>
.</p>
<p>To find the pseudoinverse <span>
  \(X^&#43;\)
</span>
 for a non-full rank matrix X, we can use the SVD decomposition. We first find the pseudoinverse of the diagonal matrix <span>
  \(\Sigma\)
</span>
. For every non-zero diagonal element <span>
  \(\sigma_i\)
</span>
, its pseudoinverse <span>
  \(\sigma_i^&#43;\)
</span>
 is <span>
  \(\frac{1}{\sigma_i}\)
</span>
. Then, the pseudoinverse of <span>
  \(\Sigma\)
</span>
, denoted as <span>
  \(\Sigma^&#43;\)
</span>
, is a diagonal matrix with the reciprocals of the non-zero diagonal elements of <span>
  \(\Sigma\)
</span>
.</p>
<p>Now, using the property of pseudoinverse for orthogonal matrices:</p>
<span>
  \(U^&#43; = U^T\)
</span>

<span>
  \(V^&#43; = V^T\)
</span>

<p>An orthogonal matrix is a square matrix where its transpose is also its inverse:</p>
<span>
  \(Q^TQ = QQ^T = I\)
</span>

<p>In the context of SVD, the matrices <span>
  \(U\)
</span>
 and <span>
  \(V\)
</span>
 are orthogonal matrices. The pseudoinverse, denoted by the superscript +, has the property that for orthogonal matrices, the pseudoinverse is equal to the transpose:</p>
<ol>
<li>For an orthogonal matrix <span>
  \(U\)
</span>
, we have <span>
  \(U^TU = UU^T = I\)
</span>
, which implies <span>
  \(U^&#43; = U^T\)
</span>
.</li>
<li>Similarly, for an orthogonal matrix <span>
  \(V\)
</span>
, we have <span>
  \(V^TV = VV^T = I\)
</span>
, which implies <span>
  \(V^&#43; = V^T\)
</span>
.</li>
</ol>
<p>The pseudoinverse <span>
  \(X^&#43;\)
</span>
 can be computed as:</p>
<span>
  \(X^&#43; = (U\Sigma V^T)^&#43; = V\Sigma^&#43; U^T\)
</span>

<p>So, we have:</p>
<span>
  \(X^&#43; = V\Sigma^{-1}U^T\)
</span>

<h2 id="mle-with-gaussian-noise">
  MLE with Gaussian noise
  <a class="anchor" href="#mle-with-gaussian-noise">#</a>
</h2>
<p>For 1-d situation:</p>
<span>
  \(y=w^Tx&#43;\epsilon,\epsilon\sim\mathcal{N}(0,\sigma^2)\)
</span>

<span>
  \(\therefore y\sim\mathcal{N}(w^Tx,\sigma^2)\)
</span>

<p>Plug it into MLE:</p>
<p><span class="optional">
  \[\begin{aligned}
L(w)=\log p(Y|X,w)&amp;=\log\prod\limits_{i=1}^Np(y_i|x_i,w)\\
&amp;=\sum\limits_{i=1}^N\log(\frac{1}{\sqrt{2\pi\sigma}}e^{-\frac{(y_i-w^Tx_i)^2}{2\sigma^2}})\\
\mathop{argmax}\limits_wL(w)&amp;=\mathop{argmin}\limits_w\sum\limits_{i=1}^N(y_i-w^Tx_i)^2
\end{aligned}\]
</span>

This expression is the same as the result obtained from the least squares estimation.</p>
<h2 id="gaussian-weight-prior-in-map-maximum-a-posteriori-estimation">
  Gaussian weight prior in MAP (Maximum A Posteriori) estimation.
  <a class="anchor" href="#gaussian-weight-prior-in-map-maximum-a-posteriori-estimation">#</a>
</h2>
<p>Take the prior distribution <span>
  \(w \sim \mathcal{N}(0, \sigma_0^2)\)
</span>
. Then:</p>
<p><span class="optional">
  \[\begin{aligned}
\hat{w} = \mathop{argmax}\limits_w p(w|Y) &amp;= \mathop{argmax}\limits_w p(Y|w) p(w)  \\
&amp;= \mathop{argmax}\limits_w \log p(Y|w) p(w)  \\
&amp;= \mathop{argmax}\limits_w (\log p(Y|w) &#43; \log p(w))  \\
&amp;= \mathop{argmin}\limits_w [(y - w^Tx)^2 &#43; \frac{\sigma^2}{\sigma_0^2} w^Tw]
\end{aligned}\]
</span>

Here, we omit <span>
  \(X\)
</span>
 as <span>
  \(p(Y)\)
</span>
 is not related to <span>
  \(w\)
</span>
, and we also use the MLE result for Gaussian distribution from above.</p>
<p>We will see that the existence of the hyperparameter <span>
  \(\sigma_0\)
</span>
 corresponds to the Ridge regularization term that will be introduced below. Similarly, if the prior distribution is taken as the Laplace distribution, a result similar to L1 regularization will be obtained.</p>
<h2 id="regularization">
  Regularization
  <a class="anchor" href="#regularization">#</a>
</h2>
<p>In practical applications, if the sample size is not much larger than the feature dimension, overfitting may occur. For this situation, we have the following three solutions:</p>
<ol>
<li>Add more data</li>
<li>Feature selection (reduce feature dimension), such as the PCA algorithm.</li>
<li>Regularization</li>
</ol>
<p>Regularization generally involves adding a regularization term (representing the penalty for the model's complexity) to the loss function (such as the least squares loss introduced above). Below, we introduce two regularization frameworks commonly used in general situations.</p>
<span class="optional">
  \[\begin{aligned}
L1&amp;:\mathop{argmin}\limits_w L(w)&#43;\lambda||w||_1,\lambda &gt; 0 \\
L2&amp;:\mathop{argmin}\limits_w L(w)&#43;\lambda||w||^2_2,\lambda &gt; 0
\end{aligned}\]
</span>

<h3 id="l1-lasso">
  L1 Lasso
  <a class="anchor" href="#l1-lasso">#</a>
</h3>
<p>Caveate: L1 regularization can lead to sparse solutions.</p>
<p>From the perspective of minimizing the loss, the derivative of the L1 term is non-zero near 0 on both the left and right sides, making it easier to obtain a solution of 0.</p>
<p>On the other hand, L1 regularization is equivalent to: <span>
  \(\mathop{argmin}\limits_w L(w) \\
s.t. ||w||_1 &lt; C\)
</span>
 We have already seen that the squared error loss function is an ellipsoid in the <span>
  \(w\)
</span>
 space. Therefore, the solution of the above equation is the tangent point between the ellipsoid and <span>
  \(||w||_1 = C\)
</span>
, making it more likely to be tangent on the coordinate axis. That means that some of the weight coefficients (w) become exactly zero. This property leads to sparsity in the solution, which can be seen as a form of automatic feature selection. However, in certain cases, it might also result in losing some potentially important information from the features whose coefficients become zero.</p>
<h3 id="l2-ridge">
  L2 Ridge
  <a class="anchor" href="#l2-ridge">#</a>
</h3>
<p><span class="optional">
  \[\begin{aligned}
\hat{w}=\mathop{argmin}\limits_wL(w)&#43;\lambda w^Tw&amp;\longrightarrow\frac{\partial}{\partial w}L(w)&#43;2\lambda w=0\\
&amp;\longrightarrow2X^TX\hat{w}-2X^TY&#43;2\lambda \hat w=0\\
&amp;\longrightarrow \hat{w}=(X^TX&#43;\lambda \mathbb{I})^{-1}X^TY
\end{aligned}\]
</span>

As we can see, this regularization parameter coincides with the previous MAP result. Using the L2 norm for regularization not only allows the model to choose smaller values for <span>
  \(w\)
</span>
, but also avoids the issue of <span>
  \(X^TX\)
</span>
 being non-invertible.</p>
<h2 id="summary">
  Summary
  <a class="anchor" href="#summary">#</a>
</h2>
<p>The linear regression model is the simplest model, but it is a miniature of every machine learning problem. Here, we use the least squares error to obtain a closed-form solution. We also find that when the noise follows a Gaussian distribution, the MLE solution is equivalent to the least squares error. Moreover, after adding a regularization term, the least squares error combined with L2 regularization is equivalent to the MAP estimation under Gaussian noise prior, and with L1 regularization, it is equivalent to the Laplace noise prior.</p>
<p>Traditional machine learning methods more or less contain elements of linear regression models:</p>
<ol>
<li>Linear models often cannot fit the data well, so there are three strategies to overcome this drawback:
<ol>
<li>Transform the feature dimensions, such as polynomial regression models, which add higher-order terms based on linear features.</li>
<li>Add a non-linear transformation after the linear equation by introducing a non-linear activation function, such as in linear classification models like perceptrons.</li>
<li>For consistent linear coefficients, we perform multiple transformations so that a single feature is not only affected by a single coefficient, such as in multilayer perceptrons (deep feedforward networks).</li>
</ol>
</li>
<li>Linear regression is linear across the entire sample space. We can modify this limitation by introducing different linear or non-linear functions in different regions, such as in linear spline regression and decision tree models.</li>
<li>Linear regression uses all the samples, but preprocessing the data might yield better learning results (the so-called curse of dimensionality, where high-dimensional data is harder to learn from), such as in PCA algorithms and manifold learning.</li>
</ol>
<h1 id="linear-classifiers">
  Linear Classifiers
  <a class="anchor" href="#linear-classifiers">#</a>
</h1>
<p>For classification tasks, linear regression models are . However, we can add an activation function to the linear model, which is non-linear. The inverse of the activation function is called the link function. We have two types of linear classification methods:</p>
<ol>
<li>Hard classification, where we directly need to output the corresponding class of the observation. Representative models of this type include:
<ol>
<li>Linear Discriminant Analysis (Fisher Discriminant)</li>
<li>Perceptron</li>
</ol>
</li>
<li>Soft classification, which generates probabilities for different classes. These algorithms can be divided into two types based on the different probability methods used:
<ol>
<li>Discriminative (directly modeling the conditional probability): Logistic Regression</li>
</ol>
</li>
</ol>
<h2 id="hard">
  Hard
  <a class="anchor" href="#hard">#</a>
</h2>
<h3 id="perceptron">
  Perceptron
  <a class="anchor" href="#perceptron">#</a>
</h3>
<p>Most intuitively, we can choose an activation function like: <span>
  \(sign(a)=\left\{\begin{matrix}&#43;1,a\ge0\\-1,a\leq0\end{matrix}\right.\)
</span>
 This way, we can map the result of linear regression to the binary classification result.</p>
<p>Define the loss function as the number of misclassified samples. Start with using the indicator function, but the indicator function is non-differentiable. Therefore, we can define: <span>
  \(L(w)=\sum\limits_{x_i\in\mathcal{D}_{wrong}}-y_iw^Tx_i\)
</span>
 where <span>
  \(\mathcal{D}_{wrong}\)
</span>
 is the set of misclassified samples. In each training step, we use the gradient descent algorithm. The partial derivative of the loss function with respect to <span>
  \(w\)
</span>
 is: <span>
  \(\frac{\partial}{\partial w}L(w)=\sum\limits_{x_i\in\mathcal{D}_{wrong}}-y_ix_i\)
</span>
 However, if there are a large number of samples, the computational complexity is high. In fact, we do not need the absolute direction of the loss function decrease. We only need the expected value of the loss function to decrease, but calculating the expectation requires knowing the true probability distribution. We can only estimate this probability distribution based on the training data sampling (empirical risk):</p>
<p><span class="optional">
  \[\mathbb{E}_{\mathcal{D}} {\mathbb{E}_{\hat{p}} {[\nabla_wL(w)]}} = \mathbb{E}_{\mathcal D}\left[\frac{1}{N}\sum\limits_{i=1}^N\nabla_wL(w)\right]\]
</span>

We know that the larger the <span>
  \(N\)
</span>
, the more accurate the sample approximation of the true distribution. However, for a data with a standard deviation of <span>
  \(\sigma\)
</span>
, the determined standard deviation is only inversely proportional to <span>
  \(\sqrt{N}\)
</span>
, while the calculation speed is directly proportional to <span>
  \(N\)
</span>
. Therefore, we can use fewer samples each time, so that the expected loss reduction and calculation speed can be improved. If we use only one misclassified sample each time, we have the following update strategy (based on the Taylor formula, in the negative direction): <span>
  \(w^{t&#43;1}\leftarrow w^{t}&#43;\lambda y_ix_i\)
</span>
 It is convergent, and using a single observation update can also increase the uncertainty to some extent, thereby reducing the possibility of falling into a local minimum. In larger-scale data, the commonly used method is <strong>mini-batch stochastic gradient descent</strong>.</p>
<h3 id="lda">
  LDA
  <a class="anchor" href="#lda">#</a>
</h3>
<p>In LDA, our basic idea is to select a direction, project the experimental samples along this direction, and the projected data should satisfy two conditions to achieve better classification:</p>
<ol>
<li>The distances between experimental samples within the same class are close.</li>
<li>The distances between different classes are larger.</li>
</ol>
<p>First, let's consider the projection. We assume that the original data is a vector <span>
  \(x\)
</span>
, then the projection along the <span>
  \(w\)
</span>
 direction is the scalar: <span>
  \(z=w^T\cdot x(=|w|\cdot|x|\cos\theta)\)
</span>
 For the first point, the samples within the same class are closer. We assume that the number of experimental samples belonging to the two classes are <span>
  \(N_1\)
</span>
 and <span>
  \(N_2\)
</span>
, respectively. We use the variance matrix to characterize the overall distribution within each class. Here we use the definition of covariance, denoted by <span>
  \(S\)
</span>
 for the original data covariance:</p>
<p><span class="optional">
  \[\begin{aligned}
C_1:Var_z[C_1]&amp;=\frac{1}{N_1}\sum\limits_{i=1}^{N_1}(z_i-\overline{z_{c1}})(z_i-\overline{z_{c1}})^T\\
&amp;=\frac{1}{N_1}\sum\limits_{i=1}^{N_1}(w^Tx_i-\frac{1}{N_1}\sum\limits_{j=1}^{N_1}w^Tx_j)(w^Tx_i-\frac{1}{N_1}\sum\limits_{j=1}^{N_1}w^Tx_j)^T\\
&amp;=w^T\frac{1}{N_1}\sum\limits_{i=1}^{N_1}(x_i-\overline{x_{c1}})(x_i-\overline{x_{c1}})^Tw\\
&amp;=w^TS_1w\\
C_2:Var_z[C_2]&amp;=\frac{1}{N_2}\sum\limits_{i=1}^{N_2}(z_i-\overline{z_{c2}})(z_i-\overline{z_{c2}})^T\\
&amp;=w^TS_2w
\end{aligned}\]
</span>

Therefore, the within-class distance can be denoted as:</p>
<p><span class="optional">
  \[\begin{aligned}
Var_z[C_1]&#43;Var_z[C_2]=w^T(S_1&#43;S_2)w
\end{aligned}\]
</span>

For the second point, we can use the means of the two classes to represent this distance:</p>
<p><span class="optional">
  \[\begin{aligned}
(\overline{z_{c1}}-\overline{z_{c2}})^2&amp;=(\frac{1}{N_1}\sum\limits_{i=1}^{N_1}w^Tx_i-\frac{1}{N_2}\sum\limits_{i=1}^{N_2}w^Tx_i)^2\\
&amp;=(w^T(\overline{x_{c1}}-\overline{x_{c2}}))^2\\
&amp;=w^T(\overline{x_{c1}}-\overline{x_{c2}})(\overline{x_{c1}}-\overline{x_{c2}})^Tw
\end{aligned}\]
</span>

Considering both points, since the covariance is a matrix, we divide these two values to obtain our loss function and maximize this value:</p>
<p><span class="optional">
  \[\begin{aligned}\hat{w}=\mathop{argmax}\limits_wJ(w)&amp;=\mathop{argmax}\limits_w\frac{(\overline{z_{c1}}-\overline{z_{c2}})^2}{Var_z[C_1]&#43;Var_z[C_2]}\\
&amp;=\mathop{argmax}\limits_w\frac{w^T(\overline{x_{c1}}-\overline{x_{c2}})(\overline{x_{c1}}-\overline{x_{c2}})^Tw}{w^T(S_1&#43;S_2)w}\\
&amp;=\mathop{argmax}\limits_w\frac{w^TS_bw}{w^TS_ww}
\end{aligned}\]
</span>

In this way, we have combined the loss function with the original dataset and parameters. Next, we will find the partial derivative of this loss function. Note that we actually have no requirement for the absolute value of <span>
  \(w\)
</span>
, only for its direction, so we can solve it with just one equation:</p>
<p><span class="optional">
  \[\begin{aligned}
&amp;\frac{\partial}{\partial w}J(w)=2S_bw(w^TS_ww)^{-1}-2w^TS_bw(w^TS_ww)^{-2}S_ww=0\\
&amp;\Longrightarrow S_bw(w^TS_ww)=(w^TS_bw)S_ww\\
&amp;\Longrightarrow w\propto S_w^{-1}S_bw=S_w^{-1}(\overline{x_{c1}}-\overline{x_{c2}})(\overline{x_{c1}}-\overline{x_{c2}})^Tw\propto S_w^{-1}(\overline{x_{c1}}-\overline{x_{c2}})
\end{aligned}\]
</span>

Thus, <span>
  \(S_w^{-1}(\overline{x_{c1}}-\overline{x_{c2}})\)
</span>
 is the direction we need to find. Finally, we can normalize it to obtain a unit <span>
  \(w\)
</span>
 value.</p>
<h2 id="soft">
  Soft
  <a class="anchor" href="#soft">#</a>
</h2>
<h3 id="logistic-regression">
  Logistic regression
  <a class="anchor" href="#logistic-regression">#</a>
</h3>
<p>Sometimes we just want to obtain the probability of a single class, so we need a function that can output values within the range of <span>
  \([0,1]\)
</span>
. Considering a binary classification model, we use a discriminative model and hope to model <span>
  \(p(C|x)\)
</span>
 using Bayes' theorem: <span>
  \(p(C_1|x)=\frac{p(x|C_1)p(C_1)}{p(x|C_1)p(C_1)&#43;p(x|C_2)p(C_2)}\)
</span>
 Let <span>
  \(a=\ln\frac{p(x|C_1)p(C_1)}{p(x|C_2)p(C_2)}\)
</span>
, then: <span>
  \(p(C_1|x)=\frac{1}{1&#43;\exp(-a)}\)
</span>
 The above formula is called the Logistic Sigmoid function, and its parameter represents the logarithm of the ratio of the joint probabilities of the two classes. In the discriminant, we do not care about the specific value of this parameter, and the model assumption is made directly for <span>
  \(a\)
</span>
.</p>
<p>The model assumption of Logistic Regression is: <span>
  \(a=w^Tx\)
</span>
 Thus, by finding the best value of <span>
  \(w\)
</span>
, we can obtain the best model under this model assumption. The probability discriminative model often uses the maximum likelihood estimation method to determine the parameters.</p>
<p>For a single observation, the probability of obtaining class <span>
  \(y\)
</span>
 is (assuming <span>
  \(C_1=1, C_2=0\)
</span>
): <span>
  \(p(y|x)=p_1^yp_0^{1-y}\)
</span>
</p>
<p>Then, for <span>
  \(N\)
</span>
 independent and identically distributed observations, the Maximum Likelihood Estimation (MLE) is: <span>
  \(\hat{w}=\mathop{argmax}_wJ(w)=\mathop{argmax}_w\sum\limits_{i=1}^N(y_i\log p_1&#43;(1-y_i)\log p_0)\)
</span>
 Notice that this expression is the negative of the cross-entropy expression multiplied by <span>
  \(N\)
</span>
. The logarithm in MLE also ensures compatibility with the exponential function, thereby obtaining stable gradients in large intervals.</p>
<p>Taking the derivative of this function, we notice that: <span>
  \(p_1&#39;=(\frac{1}{1&#43;\exp(-a)})&#39;=p_1(1-p_1)\)
</span>
 Then: <span>
  \(J&#39;(w)=\sum\limits_{i=1}^Ny_i(1-p_1)x_i-p_1x_i&#43;y_ip_1x_i=\sum\limits_{i=1}^N(y_i-p_1)x_i\)
</span>
 Due to the nonlinearity of probability values, this expression cannot be solved directly when placed in the summation symbol. Therefore, in actual training, similar to the perceptron, we can also use batch stochastic gradient ascent (or gradient descent for minimization) with different sizes to obtain the maximum value of this function.</p>
<h3 id="gaussian-discrimination-analysis">
  Gaussian Discrimination Analysis
  <a class="anchor" href="#gaussian-discrimination-analysis">#</a>
</h3>
<p>In generative models, we model the joint probability distribution and then use Maximum A Posteriori (MAP) to obtain the best parameter values. For binary classification, we adopt the following assumption:</p>
<ol>
<li><span>
  \(y\sim Bernoulli(\phi)\)
</span>
</li>
<li><span>
  \(x|y=1\sim\mathcal{N}(\mu_1,\Sigma)\)
</span>
</li>
<li><span>
  \(x|y=0\sim\mathcal{N}(\mu_0,\Sigma)\)
</span>
</li>
</ol>
<p>Then, for an independent and identically distributed dataset, the maximum a posteriori probability can be expressed as:</p>
<span class="optional">
  \[\begin{aligned}
\mathop{argmax}_{\phi,\mu_0,\mu_1,\Sigma}\log p(X|Y)p(Y)&amp;=\mathop{argmax}_{\phi,\mu_0,\mu_1,\Sigma}\sum\limits_{i=1}^N (\log p(x_i|y_i)&#43;\log p(y_i))\\
&amp;=\mathop{argmax}_{\phi,\mu_0,\mu_1,\Sigma}\sum\limits_{i=1}^N((1-y_i)\log\mathcal{N}(\mu_0,\Sigma)\\&amp;\quad&#43;y_i\log \mathcal{N}(\mu_1,\Sigma)&#43;y_i\log\phi&#43;(1-y_i)\log(1-\phi))
\end{aligned}\]
</span>

<ol>
<li>
<p>First, solve for <span>
  \(\phi\)
</span>
, and take the partial derivative of the expression with respect to <span>
  \(\phi\)
</span>
:</p>
<span class="optional">
  \[    \begin{aligned}\sum\limits_{i=1}^N\frac{y_i}{\phi}&#43;\frac{y_i-1}{1-\phi}=0\\
      \Longrightarrow\phi=\frac{\sum\limits_{i=1}^Ny_i}{N}=\frac{N_1}{N}
      \end{aligned}
    \]
</span>

</li>
<li>
<p>Solve <span>
  \(\mu_1\)
</span>
</p>
<p><span class="optional">
  \[    \begin{aligned}\hat{\mu_1}&amp;=\mathop{argmax}_{\mu_1}\sum\limits_{i=1}^Ny_i\log\mathcal{N}(\mu_1,\Sigma)\\
      &amp;=\mathop{argmin}_{\mu_1}\sum\limits_{i=1}^Ny_i(x_i-\mu_1)^T\Sigma^{-1}(x_i-\mu_1)
      \end{aligned}
    \]
</span>

<span>
  \(\because\)
</span>
 <span>
  \(      \sum\limits_{i=1}^Ny_i(x_i-\mu_1)^T\Sigma^{-1}(x_i-\mu_1)=\sum\limits_{i=1}^Ny_ix_i^T\Sigma^{-1}x_i-2y_i\mu_1^T\Sigma^{-1}x_i&#43;y_i\mu_1^T\Sigma^{-1}\mu_1
      \)
</span>
</p>
<p>Taking the derivative of the left side and multiplying by <span>
  \(\Sigma\)
</span>
 gives:</p>
<span class="optional">
  \[    \begin{aligned}\sum\limits_{i=1}^N-2y_i\Sigma^{-1}x_i&#43;2y_i\Sigma^{-1}\mu_1=0\\
      \Longrightarrow\mu_1=\frac{\sum\limits_{i=1}^Ny_ix_i}{\sum\limits_{i=1}^Ny_i}=\frac{\sum\limits_{i=1}^Ny_ix_i}{N_1}
      \end{aligned}
    \]
</span>

</li>
<li>
<p>Solve <span>
  \(\mu_0\)
</span>
: <span>
  \(      \mu_0=\frac{\sum\limits_{i=1}^N(1-y_i)x_i}{N_0}
      \)
</span>
</p>
</li>
<li>
<p>The most difficult part is solving for <span>
  \(\Sigma\)
</span>
. Our model assumes the same covariance matrix for positive and negative examples, although from the above solution, we can see that even if different matrices are used, it will not affect the previous three parameters. First, we have:</p>
<p><span class="optional">
  \[    \begin{aligned}
      \sum\limits_{i=1}^N\log\mathcal{N}(\mu,\Sigma)&amp;=\sum\limits_{i=1}^N\log(\frac{1}{(2\pi)^{p/2}|\Sigma|^{1/2}})&#43;(-\frac{1}{2}(x_i-\mu)^T\Sigma^{-1}(x_i-\mu))\\
      &amp;=Const-\frac{1}{2}N\log|\Sigma|-\frac{1}{2}Trace((x_i-\mu)^T\Sigma^{-1}(x_i-\mu))\\
      &amp;=Const-\frac{1}{2}N\log|\Sigma|-\frac{1}{2}Trace((x_i-\mu)(x_i-\mu)^T\Sigma^{-1})\\
      &amp;=Const-\frac{1}{2}N\log|\Sigma|-\frac{1}{2}NTrace(S\Sigma^{-1})
      \end{aligned}
    \]
</span>

In this expression, we add a trace to the scalar so that the order of the matrices can be exchanged. For the derivative of expressions containing absolute values and traces, we have:</p>
<p><span class="optional">
  \[    \begin{aligned}
      \frac{\partial}{\partial A}(|A|)&amp;=|A|A^{-1}\\
      \frac{\partial}{\partial A}Trace(AB)&amp;=B^T
      \end{aligned}
    \]
</span>

<span>
  \(\therefore\)
</span>
</p>
<p><span class="optional">
  \[    \begin{aligned}[\sum\limits_{i=1}^N((1-y_i)\log\mathcal{N}(\mu_0,\Sigma)&#43;y_i\log \mathcal{N}(\mu_1,\Sigma)]&#39;
      \\=Const-\frac{1}{2}N\log|\Sigma|-\frac{1}{2}N_1Trace(S_1\Sigma^{-1})-\frac{1}{2}N_2Trace(S_2\Sigma^{-1})
      \end{aligned}
    \]
</span>

In which, <span>
  \(S_1, S_2\)
</span>
 are the covariance matrices within the two classes of data, so:</p>
<p><span class="optional">
  \[    \begin{aligned}N\Sigma^{-1}-N_1S_1^T\Sigma^{-2}-N_2S_2^T\Sigma^{-2}=0
      \\\Longrightarrow\Sigma=\frac{N_1S_1&#43;N_2S_2}{N}
      \end{aligned}
    \]
</span>

The symmetry of the class covariance matrices is applied here.</p>
</li>
</ol>
<p>Thus, we have obtained all the parameters in our model assumptions using the maximum a posteriori method. According to the model, the joint distribution can be obtained, and hence the conditional distribution for inference can be derived.</p>
<h3 id="naive-bayes">
  Naive Bayes
  <a class="anchor" href="#naive-bayes">#</a>
</h3>
<p>The Gaussian discriminant analysis above assumes a Gaussian distribution for the dataset and introduces the Bernoulli distribution as the class prior, thereby obtaining the parameters within these assumptions using maximum a posteriori estimation.</p>
<p>The Naive Bayes model makes assumptions about the relationships between the properties of the data. Generally, we need to obtain the probability value <span>
  \(p(x|y)\)
</span>
. Since <span>
  \(x\)
</span>
 has <span>
  \(p\)
</span>
 dimensions, we need to sample the joint probability of these many dimensions. However, we know that a large number of samples are required to obtain a relatively accurate probability approximation in such a high-dimensional space.</p>
<p>In a general directed probabilistic graphical model, different assumptions are made about the conditional independence relationships between the dimensions of the attributes. The simplest assumption is the conditional independence assumption in the description of the Naive Bayes model: <span>
  \(p(x|y)=\prod\limits_{i=1}^pp(x_i|y)\)
</span>
 That is: <span>
  \(x_i\perp x_j|y,\forall\  i\ne j\)
</span>
 Thus, using Bayes' theorem, for a single observation: <span>
  \(p(y|x)=\frac{p(x|y)p(y)}{p(x)}=\frac{\prod\limits_{i=1}^pp(x_i|y)p(y)}{p(x)}\)
</span>
 Further assumptions are made for the individual dimensions of conditional probabilities and class priors:</p>
<ol>
<li><span>
  \(x_i\)
</span>
 is a continuous variable: <span>
  \(p(x_i|y)=\mathcal{N}(\mu_i,\sigma_i^2)\)
</span>
</li>
<li><span>
  \(x_i\)
</span>
 is a discrete variable: Categorical distribution: <span>
  \(p(x_i=i|y)=\theta_i,\sum\limits_{i=1}^K\theta_i=1\)
</span>
</li>
<li><span>
  \(p(y)=\phi^y(1-\phi)^{1-y}\)
</span>
</li>
</ol>
<p>To estimate these parameters, the MLE method is often used directly on the dataset. Since there is no need to know the relationships between the dimensions, the required amount of data is greatly reduced. After estimating these parameters, they are substituted back into Bayes' theorem to obtain the posterior distribution of the categories.</p>
<h2 id="summary-1">
  Summary
  <a class="anchor" href="#summary-1">#</a>
</h2>
<p>Classification tasks are divided into two types. For tasks that require directly outputting the class, in the perceptron algorithm, we add a sign function as an activation function to the linear model, which allows us to obtain the class. However, the sign function is not smooth, so we adopt an error-driven approach, introducing <span>
  \(\sum\limits_{x_i\in\mathcal{D}_{wrong}}-y_iw^Tx_i\)
</span>
 as the loss function, and then minimize this error using the batch stochastic gradient descent method to obtain the optimal parameter values. In linear discriminant analysis, we consider the linear model as a projection of data points in a certain direction, and use the idea of minimizing within-class variance and maximizing between-class variance to define the loss function. The within-class variance is defined as the sum of the variances of the two classes, and the between-class variance is defined as the distance between the centroids of the two classes. Taking the derivative of the loss function gives the direction of the parameters, which is <span>
  \(S_w^{-1}(\overline x_{c1}-\overline x_{c2})\)
</span>
, where <span>
  \(S_w\)
</span>
 is the sum of the variances of the two classes in the original dataset.</p>
<p>Another type of task is to output the probability of classification. For probability models, we have two schemes. The first is the discriminative model, which directly models the conditional probability of the class. By inserting the linear model into the Logistic function, we obtain the Logistic regression model. The probability interpretation here is that the logarithm of the joint probability ratio of the two classes is linear. We define the loss function as the cross-entropy (equivalent to MLE), and taking the derivative of this function gives <span>
  \(\frac{1}{N}\sum\limits_{i=1}^N(y_i-p_1)x_i\)
</span>
. We also use the batch stochastic gradient (ascent) method for optimization. The second is the generative model, which introduces the class prior. In Gaussian discriminant analysis, we assume the distribution of the dataset, where the class prior is a binomial distribution, and the likelihood of each class is a Gaussian distribution. Maximizing the log-likelihood of this joint distribution gives the parameters, <span>
  \(\frac{\sum\limits_{i=1}^Ny_ix_i}{N_1},\frac{\sum\limits_{i=1}^N(1-y_i)x_i}{N_0},\frac{N_1S_1&#43;N_2S_2}{N},\frac{N_1}{N}\)
</span>
. In Naive Bayes, we further assume the dependence between the dimensions of the attributes, and the conditional independence assumption greatly reduces the data requirements.</p>
<h1 id="support-vector-machines-svm">
  Support Vector Machines (SVM)
  <a class="anchor" href="#support-vector-machines-svm">#</a>
</h1>
<p>Support Vector Machines (SVM) play an important role in classification problems, with the main idea being to maximize the margin between two classes. Based on the characteristics of the dataset:</p>
<ol>
<li>Linearly separable problems, like those previously handled by the perceptron algorithm</li>
<li>Linearly separable, with only a few misclassified points, like the problems addressed by the evolved Pocket algorithm from the perceptron</li>
<li>Nonlinear problems, completely non-separable, such as those tackled by multilayer perceptrons and deep learning developed from the perceptron problem</li>
</ol>
<p>For these three situations, SVM has the following three methods:</p>
<ol>
<li>Hard-margin SVM</li>
<li>Soft-margin SVM</li>
<li>Kernel Method</li>
</ol>
<p>In solving SVMs, Lagrange multiplier method is widely used. First, let's start with it.</p>
<h2 id="constrained-optimization">
  Constrained Optimization
  <a class="anchor" href="#constrained-optimization">#</a>
</h2>
<p>Generally, a constrained optimization problem (original problem) can be written as:</p>
<p><span class="optional">
  \[\begin{aligned}
&amp;\min_{x\in\mathbb{R^p}}f(x)\\
&amp;s.t.\ m_i(x)\le0,i=1,2,\cdots,M\\
&amp;\ \ \ \ \ \ \ \ n_j(x)=0,j=1,2,\cdots,N
\end{aligned}\]
</span>

Define Lagrange function:</p>
<span>
  \( L(x,\lambda,\eta) = f(x) &#43; \sum_{i=1}^{M} \lambda_i m_i(x) &#43; \sum_{j=1}^{N} \eta_j n_j(x) \)
</span>

<p>Then, the original problem can be equivalently transformed into an unconstrained form:</p>
<span>
  \(\min_x \max_{\lambda, \eta} L(x,\lambda,\eta)\)
</span>

<p>where <span>
  \(\lambda\)
</span>
 is a vector of Lagrange multipliers for inequality constraints and <span>
  \(eta\)
</span>
 is a vector of Lagrange multipliers for equality constraints. Note that λ should be non-negative.</p>
<p>This unconstrained form allows us to solve the optimization problem without explicitly considering the constraints, as they are incorporated into the Lagrange function.</p>
<p>This is because, when the inequality constraints of the original problem are satisfied, the maximum value can be obtained when <span>
  \(\lambda_i=0\)
</span>
, which is directly equivalent to the original problem. If the inequality constraints of the original problem are not satisfied, the maximum value becomes <span>
  \(&#43;\infty\)
</span>
. Since the minimum value is required, this situation will not be chosen.</p>
<p>The dual form of this problem is: <span>
  \(\max_{\lambda,\eta}\min_{x\in\mathbb{R}^p}L(x,\lambda,\eta)\ s.t.\ \lambda_i\ge0\)
</span>
 The dual problem is a maximization problem with respect to <span>
  \(\lambda, \eta\)
</span>
.</p>
<p><span>
  \(\because\)
</span>
 <span>
  \(\max_{\lambda_i,\eta_j}\min_{x}L(x,\lambda_i,\eta_j)\le\min_{x}\max_{\lambda_i,\eta_j}L(x,\lambda_i,\eta_j)\)
</span>
</p>
<p>The solution of the dual problem is less than or equal to the original problem, with two situations:</p>
<ol>
<li>Strong duality: The equality can be achieved</li>
<li>Weak duality: The equality cannot be achieved</li>
</ol>
<p>For a convex optimization problem, the following theorem holds: If the convex optimization problem satisfies certain conditions, such as the Slater condition, then it and its dual problem satisfy a strong duality relationship. Let the problem's domain be defined as: <span>
  \(\mathcal{D}=domf(x)\cap dom m_i(x)\cap domn_j(x)\)
</span>
. The Slater condition is: <span>
  \(  \exists \hat{x} \in Relint \mathcal{D}\ such\ that\ \forall i=1,2,\cdots,M, m_i(x) &lt; 0
  \)
</span>
 where <span>
  \(Relint\)
</span>
 represents the relative interior (interior not containing the boundary).</p>
<p>For most convex optimization problems, the Slater condition holds; relax the Slater condition: if there are K affine functions among the M inequality constraints, then it is sufficient for the remaining functions to satisfy the Slater condition.</p>
<p>The above introduced the duality relationship between the original problem and the dual problem, but in practice, it is necessary to solve for the parameters. The solution method uses the KKT (Karush-Kuhn-Tucker) conditions:</p>
<p>The KKT conditions and the strong duality relationship are equivalent. The KKT conditions for the optimal solution are:</p>
<ol>
<li>
<p>Feasible domain:</p>
<span class="optional">
  \[    \begin{aligned}
       m_i(x^*)\le0\\
       n_j(x^*)=0\\
       \lambda^*\ge0
       \end{aligned}
    \]
</span>

</li>
<li>
<p>Complementary slackness <span>
  \(\lambda^*m_i(x^*)=0,\forall m_i\)
</span>
. The optimal value of the dual problem is <span>
  \(d^*\)
</span>
, and the original problem is <span>
  \(p^*\)
</span>
</p>
<span class="optional">
  \[    \begin{aligned}
       d^*&amp;=\max_{\lambda,\eta}g(\lambda,\eta)=g(\lambda^*,\eta^*)\\
       &amp;=\min_{x}L(x,\lambda^*,\eta^*)\\
       &amp;\le L(x^*,\lambda^*,\eta^*)\\
       &amp;=f(x^*)&#43;\sum\limits_{i=1}^M\lambda^*m_i(x^*)\\
       &amp;\le f(x^*)=p^*
       \end{aligned}
    \]
</span>

</li>
</ol>
<p>To satisfy the equality, both inequalities must hold. Therefore, for the first inequality, the gradient must be 0; for the second inequality, the complementary slackness condition must be satisfied.</p>
<ol>
<li>Gradient is 0: <span>
  \(\frac{\partial L(x,\lambda^*,\eta^*)}{\partial x}|_{x=x^*}=0\)
</span>
</li>
</ol>
<h2 id="hard-margin-svm">
  Hard-margin SVM
  <a class="anchor" href="#hard-margin-svm">#</a>
</h2>
<p>Support Vector Machine (SVM) is also a kind of hard classification model. In the previous perceptron model, we added a sign function on top of the linear model. From a geometric intuition, we can see that if the two classes are well separated, there will actually be infinitely many lines that can separate them. In SVM, we introduce the concept of maximizing the margin, where the margin refers to the minimum distance between the data and the dividing line. Maximizing this value reflects the tendency of our model.</p>
<p>The separating hyperplane can be written as: <span>
  \(0=w^Tx&#43;b\)
</span>
 Then, maximize the margin (subject to the constraints of the classification task): <span>
  \(\mathop{argmax}_{w,b}[\min_i\frac{|w^Tx_i&#43;b|}{||w||}]\ s.t.\ y_i(w^Tx_i&#43;b)&gt;0\\
\Longrightarrow\mathop{argmax}_{w,b}[\min_i\frac{y_i(w^Tx_i&#43;b)}{||w||}]\ s.t.\ y_i(w^Tx_i&#43;b)&gt;0\)
</span>
 For this constraint <span>
  \(y_i(w^Tx_i&#43;b)&gt;0\)
</span>
, we can fix <span>
  \(\min y_i(w^Tx_i&#43;b)=1&gt;0\)
</span>
, since scaling the coefficients of the hyperplane separating the two classes does not change the plane. This is equivalent to constraining the coefficients of the hyperplane. The simplified expression can be represented as: <span>
  \(\mathop{argmin}_{w,b}\frac{1}{2}w^Tw\ s.t.\ \min_iy_i(w^Tx_i&#43;b)=1\\
\Rightarrow\mathop{argmin}_{w,b}\frac{1}{2}w^Tw\ s.t.\ y_i(w^Tx_i&#43;b)\ge1,i=1,2,\cdots,N\)
</span>
 This is a convex optimization problem with <span>
  \(N\)
</span>
 constraints, and there are many software tools for solving such problems.</p>
<p>However, if the sample size or dimension is very high, solving the problem directly can be difficult or even infeasible, so further processing is needed. Introduce the Lagrange function: <span>
  \(L(w,b,\lambda)=\frac{1}{2}w^Tw&#43;\sum\limits_{i=1}^N\lambda_i(1-y_i(w^Tx_i&#43;b))\)
</span>
 The original problem is equivalent to: <span>
  \(\mathop{argmin}_{w,b}\max_{\lambda}L(w,b,\lambda_i)\ s.t.\ \lambda_i\ge0\)
</span>
 We swap the minimum and maximum symbols to obtain the dual problem: <span>
  \(\max_{\lambda_i}\min_{w,b}L(w,b,\lambda_i)\ s.t.\ \lambda_i\ge0\)
</span>
 Since the inequality constraint is an affine function, the dual problem is equivalent to the original problem:</p>
<ul>
<li>
<p><span>
  \(b\)
</span>
:<span>
  \(\frac{\partial}{\partial b}L=0\Rightarrow\sum\limits_{i=1}^N\lambda_iy_i=0\)
</span>
</p>
</li>
<li>
<p><span>
  \(w\)
</span>
:plug in <span>
  \(b\)
</span>
 <span>
  \(     L(w,b,\lambda_i)=\frac{1}{2}w^Tw&#43;\sum\limits_{i=1}^N\lambda_i(1-y_iw^Tx_i-y_ib)=\frac{1}{2}w^Tw&#43;\sum\limits_{i=1}^N\lambda_i-\sum\limits_{i=1}^N\lambda_iy_iw^Tx_i
     \)
</span>
 <span>
  \(\therefore\)
</span>
 <span>
  \(     \frac{\partial}{\partial w}L=0\Rightarrow w=\sum\limits_{i=1}^N\lambda_iy_ix_i
     \)
</span>
</p>
</li>
<li>
<p>Plug in both parameters <span>
  \(     L(w,b,\lambda_i)=-\frac{1}{2}\sum\limits_{i=1}^N\sum\limits_{j=1}^N\lambda_i\lambda_jy_iy_jx_i^Tx_j&#43;\sum\limits_{i=1}^N\lambda_i
     \)
</span>
</p>
</li>
</ul>
<p>Therefore, the dual problem is: <span>
  \(\max_{\lambda}-\frac{1}{2}\sum\limits_{i=1}^N\sum\limits_{j=1}^N\lambda_i\lambda_jy_iy_jx_i^Tx_j&#43;\sum\limits_{i=1}^N\lambda_i,\ s.t.\ \lambda_i\ge0\)
</span>
 The parameters of the hyperplane can be obtained from the KKT conditions:</p>
<p>The necessary and sufficient conditions for the strong duality relationship between the original problem and the dual problem are that they satisfy the KKT conditions:</p>
<p><span class="optional">
  \[\begin{aligned}
  &amp;\frac{\partial L}{\partial w}=0,\frac{\partial L}{\partial b}=0
  \\&amp;\lambda_k(1-y_k(w^Tx_k&#43;b))=0(slackness\ complementary)\\
  &amp;\lambda_i\ge0\\
  &amp;1-y_i(w^Tx_i&#43;b)\le0
  \end{aligned}\]
</span>

Based on these conditions, we can obtain the corresponding optimal parameters:</p>
<p><span class="optional">
  \[\begin{aligned}
\hat{w}&amp;=\sum\limits_{i=1}^N\lambda_iy_ix_i\\
\hat{b}&amp;=y_k-w^Tx_k=y_k-\sum\limits_{i=1}^N\lambda_iy_ix_i^Tx_k, \\
&amp;\exists k,1-y_k(w^Tx_k&#43;b)=0
\end{aligned}\]
</span>

Thus, the parameter <span>
  \(w\)
</span>
 of the hyperplane is a linear combination of data points, and the final parameter values are the linear combination of some vectors that satisfy <span>
  \(y_i(w^Tx_i&#43;b)=1\)
</span>
 (given by the complementary slackness condition). These vectors are also called support vectors.</p>
<h2 id="soft-margin-svm">
  Soft-margin SVM
  <a class="anchor" href="#soft-margin-svm">#</a>
</h2>
<p>Hard-margin SVM is only solvable for separable data. If the data is not separable, our basic idea is to introduce the possibility of misclassification into the loss function. The number of misclassifications can be written as: <span>
  \(error=\sum\limits_{i=1}^N\mathbb{I}\{y_i(w^Tx_i&#43;b)&lt;1\}\)
</span>
 This function is discontinuous, so we can rewrite it as: <span>
  \(error=\sum\limits_{i=1}^N\max\{0,1-y_i(w^Tx_i&#43;b)\}\)
</span>
 The term inside the summation is called the Hinge Function.</p>
<p>By adding this error term into the hard-margin SVM, we have:</p>
<p><span class="optional">
  \[\begin{aligned}
&amp;\mathop{argmin}_{w,b}\frac{1}{2}w^Tw&#43;C\sum\limits_{i=1}^N\max\{0,1-y_i(w^Tx_i&#43;b)\} \\
&amp;\textrm{s.t.} \quad y_i(w^Tx_i&#43;b)\ge1-\xi_i,i=1,2,\cdots,N
\end{aligned}\]
</span>

In this expression, the constant <span>
  \(C\)
</span>
 can be considered as the allowed error level. To further eliminate the <span>
  \(\max\)
</span>
 symbol, for each observation in the dataset, we can assume that most of them satisfy the constraint, but some of them violate the constraint. Therefore, this part of the constraint becomes <span>
  \(y_i(w^Tx&#43;b)\ge1-\xi_i\)
</span>
, where <span>
  \(\xi_i=1-y_i(w^Tx_i&#43;b)\)
</span>
. Further simplification gives: <span>
  \(\mathop{argmin}_{w,b}\frac{1}{2}w^Tw&#43;C\sum\limits_{i=1}^N\xi_i\ s.t.\ y_i(w^Tx_i&#43;b)\ge1-\xi_i,\xi_i\ge0,i=1,2,\cdots,N\)
</span>
</p>
<h2 id="kernel-method">
  Kernel Method
  <a class="anchor" href="#kernel-method">#</a>
</h2>
<p>Kernel methods can be applied to many problems. In classification problems, for strictly non-separable problems, we introduce a feature transformation function to transform the original non-separable dataset into a separable dataset, and then apply the existing model. Often, when transforming a low-dimensional dataset into a high-dimensional dataset, the data becomes separable (the data becomes sparser):</p>
<p>High-dimensional spaces are more likely to be linearly separable than low-dimensional spaces.</p>
<p>When applied to SVM, we observe the dual problem of SVM: <span>
  \(\max_{\lambda}-\frac{1}{2}\sum\limits_{i=1}^N\sum\limits_{j=1}^N\lambda_i\lambda_jy_iy_jx_i^Tx_j&#43;\sum\limits_{i=1}^N\lambda_i,\ s.t.\ \lambda_i\ge0\)
</span>
 When solving, we need to find the inner product, so after the feature transformation of non-separable data, we need to find the inner product of the transformed data. It is often difficult to find the inner product of the transformation function. Hence, we directly introduce a transformation function of the inner product: <span>
  \(\forall x,x&#39;\in\mathcal{X},\exists\phi\in\mathcal{H}:x\rightarrow z\ s.t.\ k(x,x&#39;)=\phi(x)^T\phi(x)\)
</span>
 The function <span>
  \(k(x,x&#39;)\)
</span>
 is called a positive definite kernel function, where <span>
  \(\mathcal{H}\)
</span>
 is a Hilbert space (a complete linear inner product space). If we remove the inner product condition, we simply call it a kernel function.</p>
<p><span>
  \(k(x,x&#39;)=\exp(-\frac{(x-x&#39;)^2}{2\sigma^2})\)
</span>
 is a kernel function.</p>
<p><span class="optional">
  \[\begin{aligned}
\exp(-\frac{(x-x\prime)^2}{2\sigma^2})&amp;=\exp(-\frac{x^2}{2\sigma^2})\exp(\frac{xx\prime}{\sigma^2})\exp(-\frac{x\prime^2}{2\sigma^2})\\
&amp;=\exp(-\frac{x^2}{2\sigma^2})\sum\limits_{n=0}^{&#43;\inf}\frac{x^nx\prime^n}{\sigma^{2n}n!}\exp(-\frac{x\prime^2}{2\sigma^2})\\
&amp;=\exp(-\frac{x^2}{2\sigma^2})\varphi(x)\varphi(x\prime)\exp(-\frac{x\prime^2}{2\sigma^2})\\&amp;=\phi(x)\phi(x\prime)
\end{aligned}\]
</span>

A positive definite kernel function has the following equivalent definitions:</p>
<p>If the kernel function satisfies:</p>
<ol>
<li>Symmetry</li>
<li>Positive definiteness</li>
</ol>
<p>Then this kernel function is a positive definite kernel function.</p>
<p>Proof:</p>
<ol>
<li>Symmetry <span>
  \(\Leftrightarrow\)
</span>
 <span>
  \(k(x,z)=k(z,x)\)
</span>
, which obviously satisfies the definition of an inner product.</li>
<li>Positive definiteness <span>
  \(\Leftrightarrow\)
</span>
 <span>
  \(\forall N,x_1,x_2,\cdots,x_N\in\mathcal{X}\)
</span>
, the corresponding Gram Matrix <span>
  \(K=[k(x_i,x_j)]\)
</span>
 is positive semi-definite.</li>
</ol>
<p>To prove: <span>
  \(k(x,z)=\phi(x)^T\phi(z)\Leftrightarrow K\)
</span>
 is positive semi-definite and symmetric.</p>
<ol>
<li>
<p><span>
  \(\Rightarrow\)
</span>
: Firstly, symmetry is obvious. For positive definiteness: <span>
  \(      K=\begin{pmatrix}k(x_1,x_2)&amp;\cdots&amp;k(x_1,x_N)\\\vdots&amp;\vdots&amp;\vdots\\k(x_N,x_1)&amp;\cdots&amp;k(x_N,x_N)\end{pmatrix}
      \)
</span>
 Take any <span>
  \(\alpha\in\mathbb{R}^N\)
</span>
, we need to prove <span>
  \(\alpha^TK\alpha\ge0\)
</span>
: <span>
  \(      \alpha^TK\alpha=\sum\limits_{i,j}\alpha_i\alpha_jK_{ij}=\sum\limits_{i,j}\alpha_i\phi^T(x_i)\phi(x_j)\alpha_j=\sum\limits_{i}\alpha_i\phi^T(x_i)\sum\limits_{j}\alpha_j\phi(x_j)
      \)
</span>
 This expression is in the form of an inner product. Hilbert space satisfies linearity, so the proof of positive definiteness is complete.</p>
</li>
<li>
<p><span>
  \(\Leftarrow\)
</span>
: Decompose <span>
  \(K\)
</span>
, for the symmetric matrix <span>
  \(K=V\Lambda V^T\)
</span>
, then let <span>
  \(\phi(x_i)=\sqrt{\lambda_i}V_i\)
</span>
, where <span>
  \(V_i\)
</span>
 is the eigenvector, and we construct <span>
  \(k(x,z)=\sqrt{\lambda_i\lambda_j}V_i^TV_j\)
</span>
.</p>
</li>
</ol>
<h2 id="summary-2">
  Summary
  <a class="anchor" href="#summary-2">#</a>
</h2>
<p>For a long time, classification problems relied on SVM. For strictly separable datasets, Hard-margin SVM selects a hyperplane that maximizes the distance to all data points. A constraint is applied to this plane, fixing <span>
  \(y_i(w^Tx_i&#43;b)=1\)
</span>
, resulting in a convex optimization problem with all constraint conditions as affine functions. This satisfies the Slater condition, and the problem is transformed into a dual problem, obtaining an equivalent solution and constraint parameters:</p>
<span>
  \(\max_{\lambda}-\frac{1}{2}\sum\limits_{i=1}^N\sum\limits_{j=1}^N\lambda_i\lambda_jy_iy_jx_i^Tx_j&#43;\sum\limits_{i=1}^N\lambda_i,\ s.t.\ \lambda_i\ge0\)
</span>

<p>The required hyperplane parameters are solved using the KKT conditions of the strong dual problem:</p>
<span class="optional">
  \[\begin{aligned}
&amp;\frac{\partial L}{\partial w}=0,\frac{\partial L}{\partial b}=0
\\&amp;\lambda_k(1-y_k(w^Tx_k&#43;b))=0(slackness\ complementary)\\
&amp;\lambda_i\ge0\\
&amp;1-y_i(w^Tx_i&#43;b)\le0
\end{aligned}\]
</span>

<p>The solution is:</p>
<span class="optional">
  \[\begin{aligned}
\hat{w}=\sum\limits_{i=1}^N\lambda_iy_ix_i\\
\hat{b}=y_k-w^Tx_k=y_k-\sum\limits_{i=1}^N\lambda_iy_ix_i^Tx_k \\
\exists k,1-y_k(w^Tx_k&#43;b)=0
\end{aligned}\]
</span>

<p>When allowing for some errors, an error term can be added to the Hard-margin SVM. The Hinge Function represents the size of the error term, resulting in: <span>
  \(\mathop{argmin}_{w,b}\frac{1}{2}w^Tw&#43;C\sum\limits_{i=1}^N\xi_i\ s.t.\ y_i(w^Tx_i&#43;b)\ge1-\xi_i,\xi_i\ge0,i=1,2,\cdots,N\)
</span>
</p>
<p>For completely non-separable problems, we use feature transformation. In SVM, we introduce a positive definite kernel function to directly transform the inner product. As long as this transformation satisfies symmetry and positive definiteness, it can be used as a kernel function.</p>
<h1 id="exponential-distribution">
  Exponential Distribution
  <a class="anchor" href="#exponential-distribution">#</a>
</h1>
<p>The exponential family is a class of distributions that includes Gaussian distribution, Bernoulli distribution, binomial distribution, Poisson distribution, Beta distribution, Dirichlet distribution, Gamma distribution, and a series of other distributions. Exponential family distributions can be written in a unified form:</p>
<span>
  \(p(x|\eta)=h(x)\exp(\eta^T\phi(x)-A(\eta))=\frac{1}{\exp(A(\eta))}h(x)\exp(\eta^T\phi(x))\)
</span>

<p><span>
  \(\eta\)
</span>
 is the parameter vector, and <span>
  \(A(\eta)\)
</span>
 is the log partition function (normalization factor).</p>
<p>In this expression, <span>
  \(\phi(x)\)
</span>
 is called the sufficient statistic, containing all the information of the sample set, such as the mean and variance in the Gaussian distribution. Sufficient statistics have applications in online learning; for a dataset, it is only necessary to record the sufficient statistics of the samples.</p>
<p>For a model distribution assumption (likelihood), we often need to find a conjugate prior in the solution, so that the prior and posterior forms are the same. For example, if the likelihood is a binomial distribution, the prior can be chosen as a Beta distribution, and the posterior is also a Beta distribution. Exponential family distributions often have conjugate properties, making model selection and inference much more convenient.</p>
<p>The properties of conjugate priors facilitate computation, and at the same time, exponential family distributions satisfy the idea of maximum entropy (uninformative prior). That is, the distribution derived from the empirical distribution using the principle of maximum entropy is the exponential family distribution.</p>
<p>Noticing that the expression of the exponential family distribution is similar to the linear model, in fact, the exponential family distribution naturally derives the generalized linear model: <span>
  \(y=f(w^Tx)\\
y|x\sim Exp Family\)
</span>
 In more complex probabilistic graphical models, such as in undirected graphical models like Restricted Boltzmann Machines, exponential family distributions also play an important role.</p>
<p>In inference algorithms, such as variational inference, exponential family distributions greatly simplify the computation.</p>
<h2 id="1-_d_-gaussian-distribution">
  1-<em>d</em> Gaussian distribution
  <a class="anchor" href="#1-_d_-gaussian-distribution">#</a>
</h2>
<p>1-<span>
  \(d\)
</span>
 Gaussian distribution can be written as: <span>
  \(p(x|\theta)=\frac{1}{\sqrt{2\pi}\sigma}\exp(-\frac{(x-\mu)^2}{2\sigma^2})\)
</span>
</p>
<p>Now transform the above:</p>
<p><span class="optional">
  \[\begin{aligned}
&amp;\frac{1}{\sqrt{2\pi\sigma^2}}\exp(-\frac{1}{2\sigma^2}(x^2-2\mu x&#43;\mu^2))\\
&amp;=\exp(\log(2\pi\sigma^2)^{-1/2})\exp(-\frac{1}{2\sigma^2}\begin{pmatrix}-2\mu&amp;1\end{pmatrix}\begin{pmatrix}x\\x^2\end{pmatrix}-\frac{\mu^2}{2\sigma^2})
\end{aligned}\]
</span>

<span>
  \(\therefore\)
</span>
 <span>
  \(\eta=\begin{pmatrix}\frac{\mu}{\sigma^2}\\-\frac{1}{2\sigma^2}\end{pmatrix}=\begin{pmatrix}\eta_1\\\eta_2\end{pmatrix}\)
</span>
, <span>
  \(A(\eta)=-\frac{\eta_1^2}{4\eta_2}&#43;\frac{1}{2}\log(-\frac{\pi}{\eta_2})\)
</span>
</p>
<h2 id="sufficient-statistics-and-log-partition-functions">
  Sufficient statistics and log partition functions
  <a class="anchor" href="#sufficient-statistics-and-log-partition-functions">#</a>
</h2>
<p>Integrate the probability density function:</p>
<p><span class="optional">
  \[\begin{aligned}
\exp(A(\eta))&amp;=\int h(x)\exp(\eta^T\phi(x))dx
\end{aligned}\]
</span>

Take the derivative with respect to the parameter on both sides:</p>
<p><span class="optional">
  \[\begin{aligned}
\exp(A(\eta))A&#39;(\eta)&amp;=\int h(x)\exp(\eta^T\phi(x))\phi(x)dx\\
\Longrightarrow A&#39;(\eta)&amp;=\mathbb{E}_{p(x|\eta)}[\phi(x)]
\end{aligned}\]
</span>

Similarly: <span>
  \(A&#39;&#39;(\eta)=Var_{p(x|\eta)}[\phi(x)]\)
</span>
</p>
<p>Since the variance is positive, <span>
  \(A(\eta)\)
</span>
 must be a convex function.</p>
<h2 id="sufficient-statistics-and-mle">
  Sufficient statistics and MLE
  <a class="anchor" href="#sufficient-statistics-and-mle">#</a>
</h2>
<p>For an independently and identically distributed (<span>
  \(iid\)
</span>
) dataset <span>
  \(\mathcal{D}=\{x_1,x_2,\cdots,x_N\}\)
</span>
</p>
<p><span class="optional">
  \[\begin{aligned}
\eta_{MLE}&amp;=\mathop{argmax}_\eta\sum\limits_{i=1}^N\log p(x_i|\eta)\\
&amp;=\mathop{argmax}_\eta\sum\limits_{i=1}^N(\eta^T\phi(x_i)-A(\eta))\\
&amp;\Longrightarrow A&#39;(\eta_{MLE})=\frac{1}{N}\sum\limits_{i=1}^N\phi(x_i)
\end{aligned}\]
</span>

From this, we can see that in order to estimate the parameters, it is sufficient to know the sufficient statistics.</p>
<h2 id="maximum-entrophy">
  Maximum entrophy
  <a class="anchor" href="#maximum-entrophy">#</a>
</h2>
<p>The information entropy is denoted as: <span>
  \(Entropy=\int-p(x)\log(p(x))dx\)
</span>
</p>
<p>In general, for a completely random variable (equally likely), the information entropy is maximized.</p>
<p>Our assumption is based on the principle of maximum entropy. Assuming the data follows a discrete distribution with probability of <span>
  \(k\)
</span>
 features being <span>
  \(p_k\)
</span>
, the principle of maximum entropy can be formulated as: <span>
  \(  \max\{H(p)\}=\min\{\sum\limits_{k=1}^Kp_k\log p_k\}\ s.t.\ \sum\limits_{k=1}^Kp_k=1
  \)
</span>
</p>
<p>Using the Lagrange multiplier method: <span>
  \(  L(p,\lambda)=\sum\limits_{k=1}^Kp_k\log p_k&#43;\lambda(1-\sum\limits_{k=1}^Kp_k)
  \)
</span>
</p>
<p>Hence, we can obtain: <span>
  \(  p_1=p_2=\cdots=p_K=\frac{1}{K}
  \)
</span>
</p>
<p>Therefore, the entropy is maximized when all probabilities are equal.</p>
<p>For a dataset <span>
  \(\mathcal{D}\)
</span>
, the empirical distribution on this dataset is <span>
  \(\hat{p}(x)=\frac{Count(x)}{N}\)
</span>
. In practice, it is impossible to satisfy all empirical probabilities being equal. Therefore, we need to add the constraint of this empirical distribution in the principle of maximum entropy.</p>
<p>For any function, the empirical expectation of the empirical distribution can be obtained as: <span>
  \(\mathbb{E}_{\hat{p}}[f(x)]=\Delta\)
</span>
</p>
<span>
  \(\therefore
\max\{H(p)\}=\min\{\sum\limits_{k=1}^Np_k\log p_k\}\ s.t.\ \sum\limits_{k=1}^Np_k=1,\mathbb{E}_p[f(x)]=\Delta\)
</span>

<p>The Lagrange function is: <span>
  \(L(p,\lambda_0,\lambda)=\sum\limits_{k=1}^Np_k\log p_k&#43;\lambda_0(1-\sum\limits_{k=1}^Np_k)&#43;\lambda^T(\Delta-\mathbb{E}_p[f(x)])\)
</span>
</p>
<p>Taking the derivative, we get:</p>
<span>
  \(\frac{\partial}{\partial p(x)}L=\sum\limits_{k=1}^N(\log p(x)&#43;1)-\sum\limits_{k=1}^N\lambda_0-\sum\limits_{k=1}^N\lambda^Tf(x)\\
\Longrightarrow\sum\limits_{k=1}^N\log p(x)&#43;1-\lambda_0-\lambda^Tf(x)=0\)
</span>

<p>Since the dataset is arbitrary, summing over the dataset also means that every term in the sum is 0: <span>
  \(p(x)=\exp(\lambda^Tf(x)&#43;\lambda_0-1)\)
</span>
 This is the exponential family distribution.</p>
<h1 id="expectation--maximization-algorithm">
  Expectation&ndash;Maximization Algorithm
  <a class="anchor" href="#expectation--maximization-algorithm">#</a>
</h1>
<p>The purpose of the Expectation-Maximization (EM) algorithm is to solve the parameter estimation (maximum likelihood estimation) for mixture models with latent variables. The MLE for the parameter estimation of <span>
  \(p(x|\theta)\)
</span>
 is denoted as: <span>
  \(\theta_{MLE}=\mathop{argmax}\limits_\theta\log p(x|\theta)\)
</span>
. The EM algorithm solves this problem using an iterative method:</p>
<span>
  \(\theta^{\text{t}&#43;1} = \arg\max_{\theta} \int_{z} \log [p(x,z|\theta)] p(z|x,\theta^{\text{t}}) dz = \mathbb{E}_{z|x,\theta^{\text{t}}}[\log p(x,z|\theta)]\)
</span>

<p>This formula includes two iterative steps:</p>
<ol>
<li>E step: Calculate the expectation of <span>
  \(\log p(x,z|\theta)\)
</span>
 under the probability distribution <span>
  \(p(z|x,\theta^t)\)
</span>
</li>
<li>M step: Calculate the parameters that maximize this expectation to obtain the input for the next EM step</li>
</ol>
<span>
  \(\log p(x|\theta^t)\le\log p(x|\theta^{t&#43;1})\)
</span>

<span>
  \(\log p(x|\theta)=\log p(z,x|\theta)-\log p(z|x,\theta)\)
</span>

<p>Integrate both sides:</p>
<p>\begin{aligned}
Left:&amp;\int_zp(z|x,\theta^t)\log p(x|\theta)dz=\log p(x|\theta) \
Right:&amp;\int_zp(z|x,\theta^t)\log p(x,z|\theta)dz-\int_zp(z|x,\theta^t)\log p(z|x,\theta)dz=Q(\theta,\theta^t)-H(\theta,\theta^t)
\end{aligned}</p>
<span>
  \(\therefore
  \log p(x|\theta)=Q(\theta,\theta^t)-H(\theta,\theta^t)\)
</span>

<p>\begin{aligned}
\because Q(\theta,\theta^t)&amp;=\int_zp(z|x,\theta^t)\log p(x,z|\theta)dz \
\theta^{t+1}&amp;=\mathop{argmax}\limits_{\theta}\int_z\log [p(x,z|\theta)]p(z|x,\theta^t)dz \
\therefore Q(\theta^{t+1},\theta^t)&amp;\ge Q(\theta^t,\theta^t)
\end{aligned}</p>
<p>To have <span>
  \(\log p(x|\theta^t)\le\log p(x|\theta^{t&#43;1})\)
</span>
</p>
<p>We need <span>
  \(H(\theta^t,\theta^t)\ge H(\theta^{t&#43;1},\theta^t)\)
</span>
</p>
<p>\begin{aligned}
H(\theta^{t+1},\theta^t)-H(\theta^{t},\theta^t)&amp;=\int_zp(z|x,\theta^{t})\log p(z|x,\theta^{t+1})dz-\int_zp(z|x,\theta^t)\log p(z|x,\theta^{t})dz\
&amp;=\int_zp(z|x,\theta^t)\log\frac{p(z|x,\theta^{t+1})}{p(z|x,\theta^t)} \
&amp;=-KL(p(z|x,\theta^t),p(z|x,\theta^{t+1}))\le0
\end{aligned}</p>
<p>Combining everything we have got: <span>
  \(  \log p(x|\theta^t)\le\log p(x|\theta^{t&#43;1})
  \)
</span>
</p>
<p>Based on the proof above, we see that the likelihood function increases at each step. Furthermore, we look at how the formula in the EM iteration process is derived:</p>
<span>
  \(\log p(x|\theta)=\log p(z,x|\theta)-\log p(z|x,\theta)=\log \frac{p(z,x|\theta)}{q(z)}-\log \frac{p(z|x,\theta)}{q(z)}\)
</span>

<p>Take the expectation <span>
  \(\mathbb{E}_{q(z)}\)
</span>
 on both sides:</p>
<p><span class="optional">
  \[\begin{aligned}
&amp;Left:\int_zq(z)\log p(x|\theta)dz=\log p(x|\theta)\\
&amp;Right:\int_zq(z)\log \frac{p(z,x|\theta)}{q(z)}dz-\int_zq(z)\log \frac{p(z|x,\theta)}{q(z)}dz=ELBO&#43;KL(q(z),p(z|x,\theta))
\end{aligned}\]
</span>

In the equation above, the Evidence Lower Bound (ELBO) is a lower bound, so <span>
  \(\log p(x|\theta)\ge ELBO\)
</span>
. The equality holds when the KL divergence is 0, i.e., <span>
  \(q(z)=p(z|x,\theta)\)
</span>
. The purpose of the EM algorithm is to maximize the ELBO. According to the proof process above, the maximum ELBO is obtained at each step of EM, and the parameters that maximize the ELBO are used as input for the next step:</p>
<span>
  \(\hat{\theta}=\mathop{argmax}_{\theta}ELBO=\mathop{argmax}_\theta\int_zq(z)\log\frac{p(x,z|\theta)}{q(z)}dz\)
</span>

<p>Since the maximum value can be achieved when <span>
  \( q(z)=p(z|x,\theta^t)\)
</span>
, we have:</p>
<p><span class="optional">
  \[\begin{aligned}
\hat{\theta}&amp;=\mathop{argmax}_{\theta}ELBO \\
&amp;=\mathop{argmax}_\theta\int_zq(z)\log\frac{p(x,z|\theta)}{q(z)}dz \\
&amp;=\mathop{argmax}_\theta\int_zp(z|x,\theta^t)\log\frac{p(x,z|\theta)}{p(z|x,\theta^t)}dz \\
&amp;=\mathop{argmax}_\theta\int_z p(z|x,\theta^t)\log p(x,z|\theta)
\end{aligned}\]
</span>

This formula is the one used in the EM iteration process above.</p>
<p>Starting from Jensen's inequality, this formula can also be derived:</p>
<p><span class="optional">
  \[\begin{aligned}
\log p(x|\theta)&amp;=\log\int_zp(x,z|\theta)dz \\
&amp;=\log\int_z\frac{p(x,z|\theta)q(z)}{q(z)}dz \\
&amp;=\log \mathbb{E}_{q(z)}[\frac{p(x,z|\theta)}{q(z)}] \\
&amp;\ge \mathbb{E}_{q(z)}[\log\frac{p(x,z|\theta)}{q(z)}]
\end{aligned}\]
</span>

In this case, the right side of the equation is the ELBO, and the equality holds when <span>
  \( p(x,z|\theta)=Cq(z)\)
</span>
.</p>
<p>Thus: <span>
  \(\int_zq(z)dz=\frac{1}{C}\int_zp(x,z|\theta)dz=\frac{1}{C}p(x|\theta)=1\\
\Rightarrow q(z)=\frac{1}{p(x|\theta)}p(x,z|\theta)=p(z|x,\theta)\)
</span>
</p>
<p>We find that this process is the condition for the maximum value to hold as discussed above.</p>
<h2 id="generalized-em">
  Generalized EM
  <a class="anchor" href="#generalized-em">#</a>
</h2>
<p>The EM model solves the problem of parameter estimation for probabilistic generative models by introducing latent variable <span>
  \(z\)
</span>
 to learn <span>
  \(\theta\)
</span>
, and specific models have different assumptions for <span>
  \(z\)
</span>
. For the learning task <span>
  \(p(x|\theta)\)
</span>
, it is the learning task <span>
  \(\frac{p(x,z|\theta)}{p(z|x,\theta)}\)
</span>
. In this formula, we assume that in the E step, <span>
  \(q(z)=p(z|x,\theta)\)
</span>
. However, if this <span>
  \(p(z|x,\theta)\)
</span>
 cannot be solved, sampling (MCMC) or variational inference methods must be used to approximate this posterior. We observe the expression of KL divergence. To maximize the ELBO, we need to minimize the KL divergence when <span>
  \(\theta\)
</span>
 is fixed:</p>
<span>
  \(\hat{q}(z)=\mathop{argmin}_qKL(p,q)=\mathop{argmax}_qELBO\)
</span>

<p>This is the basic idea of the generalized EM:</p>
<ol>
<li>
<p>E step: <span>
  \(      \hat{q}^{t&#43;1}(z)=\mathop{argmax}_q\int_zq^t(z)\log\frac{p(x,z|\theta)}{q^t(z)}dz, \text{ fixed }\theta
      \)
</span>
</p>
</li>
<li>
<p>M step: <span>
  \(      \hat{\theta}=\mathop{argmax}_\theta \int_zq^{t&#43;1}(z)\log\frac{p(x,z|\theta)}{q^{t&#43;1}(z)}dz, \text{ fixed }\hat{q}
      \)
</span>
</p>
</li>
</ol>
<p>For the integration above: <span>
  \(ELBO=\int_zq(z)\log\frac{p(x,z|\theta)}{q(z)}dz=\mathbb{E}_{q(z)}[p(x,z|\theta)]&#43;Entropy(q(z))\)
</span>
</p>
<p>Therefore, we see that the generalized EM is equivalent to adding an entropy term to the original formula.</p>
<h2 id="generalization-of-em">
  Generalization of EM
  <a class="anchor" href="#generalization-of-em">#</a>
</h2>
<p>The EM algorithm is similar to the coordinate ascent method, where some coordinates are fixed and others are optimized, and then iterated repeatedly. If the posterior probability of <span>
  \(z\)
</span>
 cannot be solved within the EM framework, some variations of EM need to be adopted to estimate this posterior.</p>
<ol>
<li>Variational inference based on mean-field, VBEM/VEM</li>
<li>Monte Carlo-based EM, MCEM</li>
</ol>
<h1 id="gaussian-mixture-model">
  Gaussian Mixture Model
  <a class="anchor" href="#gaussian-mixture-model">#</a>
</h1>
<p>To solve the unimodality problem of the Gaussian model, we introduce the weighted average of multiple Gaussian models to fit the multimodal data:</p>
<span>
  \(p(x)=\sum\limits_{k=1}^K\alpha_k\mathcal{N}(\mu_k,\Sigma_k)\)
</span>

<p>We introduce the latent variable <span>
  \(z\)
</span>
, which represents which Gaussian distribution the corresponding sample <span>
  \(x\)
</span>
 belongs to. This variable is a discrete random variable:</p>
<span>
  \(p(z=i)=p_i,\sum\limits_{i=1}^kp(z=i)=1\)
</span>

<p>As a generative model, the Gaussian mixture model generates samples through the distribution of the latent variable <span>
  \(z\)
</span>
. It can be represented with a probability graph:</p>
<p><img src="./img/gmm_1d.png" alt="" />{width=&ldquo;30px&rdquo;}</p>
<p>In this graph, node <span>
  \(z\)
</span>
 represents the probability mentioned above, and <span>
  \(x\)
</span>
 represents the generated Gaussian distribution.</p>
<p>Therefore, for <span>
  \(p(x)\)
</span>
: <span>
  \(p(x)=\sum\limits_zp(x,z)=\sum\limits_{k=1}^Kp(x,z=k)=\sum\limits_{k=1}^Kp(z=k)p(x|z=k)\)
</span>
</p>
<p>Thus: <span>
  \(p(x)=\sum\limits_{k=1}^Kp_k\mathcal{N}(x|\mu_k,\Sigma_k)\)
</span>
</p>
<h2 id="mle">
  MLE
  <a class="anchor" href="#mle">#</a>
</h2>
<p>The samples are <span>
  \(X=(x_1,x_2,\cdots,x_N)\)
</span>
, and <span>
  \((X,Z)\)
</span>
 are the complete parameters, with the parameters being <span>
  \(\theta=\{p_1,p_2,\cdots,p_K,\mu_1,\mu_2,\cdots,\mu_K\Sigma_1,\Sigma_2,\cdots,\Sigma_K\}\)
</span>
</p>
<p>We obtain the value of <span>
  \(\theta\)
</span>
 through maximum likelihood estimation:</p>
<p><span class="optional">
  \[\begin{aligned}\theta_{MLE}&amp;=\mathop{argmax}\limits_{\theta}\log p(X)=\mathop{argmax}_{\theta}\sum\limits_{i=1}^N\log p(x_i)\\
&amp;=\mathop{argmax}_\theta\sum\limits_{i=1}^N\log \sum\limits_{k=1}^Kp_k\mathcal{N}(x_i|\mu_k,\Sigma_k)
\end{aligned}\]
</span>

This expression cannot be obtained by direct derivation due to the presence of the summation, so the EM algorithm is needed.</p>
<h2 id="solve-gmm-using-em">
  Solve GMM using EM
  <a class="anchor" href="#solve-gmm-using-em">#</a>
</h2>
<p>The basic expression of the EM algorithm is: <span>
  \(\theta^{t&#43;1}=\mathop{argmax}\limits_{\theta}\mathbb{E}_{z|x,\theta_t}[p(x,z|\theta)]\)
</span>
. Applying the GMM expression for the dataset, we get:</p>
<span class="optional">
  \[\begin{aligned}
Q(\theta,\theta^t)&amp;=\sum\limits_z[\log\prod\limits_{i=1}^Np(x_i,z_i|\theta)]\prod \limits_{i=1}^Np(z_i|x_i,\theta^t)\\
&amp;=\sum\limits_z[\sum\limits_{i=1}^N\log p(x_i,z_i|\theta)]\prod \limits_{i=1}^Np(z_i|x_i,\theta^t)
\end{aligned}\]
</span>

<p>For the summation in the middle, expanding the first term, we have:</p>
<p><span class="optional">
  \[\begin{aligned}
\sum\limits_z\log p(x_1,z_1|\theta)\prod\limits_{i=1}^Np(z_i|x_i,\theta^t)&amp;=\sum\limits_z\log p(x_1,z_1|\theta)p(z_1|x_1,\theta^t)\prod\limits_{i=2}^Np(z_i|x_i,\theta^t)\\
&amp;=\sum\limits_{z_1}\log p(x_1,z_1|\theta)
p(z_1|x_1,\theta^t)\sum\limits_{z_2,\cdots,z_K}\prod\limits_{i=2}^Np(z_i|x_i,\theta^t)\\
&amp;=\sum\limits_{z_1}\log p(x_1,z_1|\theta)p(z_1|x_1,\theta^t)
\end{aligned}\]
</span>

Similarly, <span>
  \(Q\)
</span>
 can be written as: <span>
  \(Q(\theta,\theta^t)=\sum\limits_{i=1}^N\sum\limits_{z_i}\log p(x_i,z_i|\theta)p(z_i|x_i,\theta^t)\)
</span>
</p>
<p>For <span>
  \(p(x,z|\theta)\)
</span>
: <span>
  \(p(x,z|\theta)=p(z|\theta)p(x|z,\theta)=p_z\mathcal{N}(x|\mu_z,\Sigma_z)\)
</span>
</p>
<p>For <span>
  \(p(z|x,\theta^t)\)
</span>
: <span>
  \(p(z|x,\theta^t)=\frac{p(x,z|\theta^t)}{p(x|\theta^t)}=\frac{p_z^t\mathcal{N}(x|\mu_z^t,\Sigma_z^t)}{\sum\limits_kp_k^t\mathcal{N}(x|\mu_k^t,\Sigma_k^t)}\)
</span>
</p>
<p>Plug in <span>
  \(Q\)
</span>
:</p>
<span>
  \(Q=\sum\limits_{i=1}^N\sum\limits_{z_i}\log p_{z_i}\mathcal{N(x_i|\mu_{z_i},\Sigma_{z_i})}\frac{p_{z_i}^t\mathcal{N}(x_i|\mu_{z_i}^t,\Sigma_{z_i}^t)}{\sum\limits_kp_k^t\mathcal{N}(x_i|\mu_k^t,\Sigma_k^t)}\)
</span>

<p>Find maximum of <span>
  \(Q\)
</span>
: <span>
  \(Q=\sum\limits_{k=1}^K\sum\limits_{i=1}^N[\log p_k&#43;\log \mathcal{N}(x_i|\mu_k,\Sigma_k)]p(z_i=k|x_i,\theta^t)\)
</span>
</p>
<ol>
<li>
<p><span>
  \(p_k^{t&#43;1}\)
</span>
:</p>
<span>
  \(      p_k^{t&#43;1}=\mathop{argmax}_{p_k}\sum\limits_{k=1}^K\sum\limits_{i=1}^N[\log p_k&#43;\log \mathcal{N}(x_i|\mu_k,\Sigma_k)]p(z_i=k|x_i,\theta^t)\ s.t.\ \sum\limits_{k=1}^Kp_k=1
      \)
</span>

<span>
  \(\therefore\\
      p_k^{t&#43;1}=\mathop{argmax}_{p_k}\sum\limits_{k=1}^K\sum\limits_{i=1}^N\log p_kp(z_i=k|x_i,\theta^t)\ s.t.\ \sum\limits_{k=1}^Kp_k=1
      \)
</span>

<p>Introduce a Lagrange multiplier:</p>
<span>
  \(L(p_k,\lambda)=\sum\limits_{k=1}^K\sum\limits_{i=1}^N\log p_kp(z_i=k|x_i,\theta^t)-\lambda(1-\sum\limits_{k=1}^Kp_k)\)
</span>

<span>
  \(\therefore\\
      \frac{\partial}{\partial p_k}L=\sum\limits_{i=1}^N\frac{1}{p_k}p(z_i=k|x_i,\theta^t)&#43;\lambda=0\\
      \Rightarrow \sum\limits_k\sum\limits_{i=1}^N\frac{1}{p_k}p(z_i=k|x_i,\theta^t)&#43;\lambda\sum\limits_kp_k=0\\
      \Rightarrow\lambda=-N
      \)
</span>

<span>
  \(\therefore\\
      p_k^{t&#43;1}=\frac{1}{N}\sum\limits_{i=1}^Np(z_i=k|x_i,\theta^t)
      \)
</span>

</li>
<li>
<p><span>
  \(\mu_k,\Sigma_k\)
</span>
, these two parameters are unconstrained, and can be directly derived.</p>
</li>
</ol>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#frequentist">Frequentist</a></li>
    <li><a href="#bayesian">Bayesian</a></li>
  </ul>

  <ul>
    <li><a href="#1-d-mle">1-d MLE</a></li>
    <li><a href="#multivariate-gaussian">Multivariate Gaussian</a></li>
  </ul>

  <ul>
    <li><a href="#least-squares-method">Least squares method</a></li>
    <li><a href="#mle-with-gaussian-noise">MLE with Gaussian noise</a></li>
    <li><a href="#gaussian-weight-prior-in-map-maximum-a-posteriori-estimation">Gaussian weight prior in MAP (Maximum A Posteriori) estimation.</a></li>
    <li><a href="#regularization">Regularization</a>
      <ul>
        <li><a href="#l1-lasso">L1 Lasso</a></li>
        <li><a href="#l2-ridge">L2 Ridge</a></li>
      </ul>
    </li>
    <li><a href="#summary">Summary</a></li>
  </ul>

  <ul>
    <li><a href="#hard">Hard</a>
      <ul>
        <li><a href="#perceptron">Perceptron</a></li>
        <li><a href="#lda">LDA</a></li>
      </ul>
    </li>
    <li><a href="#soft">Soft</a>
      <ul>
        <li><a href="#logistic-regression">Logistic regression</a></li>
        <li><a href="#gaussian-discrimination-analysis">Gaussian Discrimination Analysis</a></li>
        <li><a href="#naive-bayes">Naive Bayes</a></li>
      </ul>
    </li>
    <li><a href="#summary-1">Summary</a></li>
  </ul>

  <ul>
    <li><a href="#constrained-optimization">Constrained Optimization</a></li>
    <li><a href="#hard-margin-svm">Hard-margin SVM</a></li>
    <li><a href="#soft-margin-svm">Soft-margin SVM</a></li>
    <li><a href="#kernel-method">Kernel Method</a></li>
    <li><a href="#summary-2">Summary</a></li>
  </ul>

  <ul>
    <li><a href="#1-_d_-gaussian-distribution">1-<em>d</em> Gaussian distribution</a></li>
    <li><a href="#sufficient-statistics-and-log-partition-functions">Sufficient statistics and log partition functions</a></li>
    <li><a href="#sufficient-statistics-and-mle">Sufficient statistics and MLE</a></li>
    <li><a href="#maximum-entrophy">Maximum entrophy</a></li>
  </ul>

  <ul>
    <li><a href="#generalized-em">Generalized EM</a></li>
    <li><a href="#generalization-of-em">Generalization of EM</a></li>
  </ul>

  <ul>
    <li><a href="#mle">MLE</a></li>
    <li><a href="#solve-gmm-using-em">Solve GMM using EM</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












